+ [author](http://nsddd.top)

# ç¬¬69èŠ‚  DeltaFIFO åŸç†

<div><a href = '68.md' style='float:left'>â¬†ï¸ä¸Šä¸€èŠ‚ğŸ”—  </a><a href = '70.md' style='float: right'>  â¬‡ï¸ä¸‹ä¸€èŠ‚ğŸ”—</a></div>
<br>

> â¤ï¸ğŸ’•ğŸ’•æ–°æ—¶ä»£æ‹¥æŠ±äº‘åŸç”Ÿï¼Œäº‘åŸç”Ÿå…·æœ‰ç¯å¢ƒç»Ÿä¸€ã€æŒ‰éœ€ä»˜è´¹ã€å³å¼€å³ç”¨ã€ç¨³å®šæ€§å¼ºç‰¹ç‚¹ã€‚Myblog:[http://nsddd.top](http://nsddd.top/)

---
[TOC]

## ä»‹ç»

okkey æˆ‘ä»¬çŸ¥é“ï¼Œå†ä¸Šä¸€ä¸ª Reflector ä» API Server ç›‘å¬ï¼ˆwatchï¼‰ç‰¹å®šç±»å‹çš„èµ„æºï¼Œæ‹¿åˆ°å˜æ›´é€šçŸ¥åï¼Œå°†å…¶æ”¾å…¥åˆ° DeltaFIFO é˜Ÿåˆ—ä¸­ã€‚

**DeltaFIFO  æ˜¯ Kubernetes ä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªå­˜å‚¨ã€‚**

ä¸ä»…ä»…æ˜¯ DeltaFIFO ï¼Œ Kubernetes è¿˜ä¸ºæˆ‘ä»¬æä¾›äº†å¾ˆå¤šå­˜å‚¨



## Kubernetes æä¾›çš„å­˜å‚¨

cache ä¸»è¦å®ç°äº† Storeï¼Œåˆ©ç”¨äº† `threadSafeMap` å­˜æ”¾æ•°æ®

```bash
type Store interface {

	// Add adds the given object to the accumulator associated with the given object's key
	Add(obj interface{}) error

	// Update updates the given object in the accumulator associated with the given object's key
	Update(obj interface{}) error

	// Delete deletes the given object from the accumulator associated with the given object's key
	Delete(obj interface{}) error

	// List returns a list of all the currently non-empty accumulators
	List() []interface{}

	// ListKeys returns a list of all the keys currently associated with non-empty accumulators
	ListKeys() []string

	// Get returns the accumulator associated with the given object's key
	Get(obj interface{}) (item interface{}, exists bool, err error)

	// GetByKey returns the accumulator associated with the given key
	GetByKey(key string) (item interface{}, exists bool, err error)

	// Replace will delete the contents of the store, using instead the
	// given list. Store takes ownership of the list, you should not reference
	// it after calling this function.
	Replace([]interface{}, string) error

	// Resync is meaningless in the terms appearing here but has
	// meaning in some implementations that have non-trivial
	// additional behavior (e.g., DeltaFIFO).
	Resync() error
}
```

**ğŸ“œ å¯¹ä¸Šé¢çš„è§£é‡Šï¼š**

+ `Add(obj interface{}) error`: å°†ç»™å®šå¯¹è±¡æ·»åŠ åˆ°ä¸ç»™å®šå¯¹è±¡çš„é”®ç›¸å…³è”çš„ç´¯åŠ å™¨ä¸­
+ `Update(obj interface{}) error`: æ›´æ–°ä¸ç»™å®šå¯¹è±¡çš„é”®ç›¸å…³è”çš„ç´¯åŠ å™¨ä¸­çš„ç»™å®šå¯¹è±¡
+ `Delete(obj interface{}) error`: ä»ä¸ç»™å®šå¯¹è±¡çš„é”®ç›¸å…³è”çš„ç´¯åŠ å™¨ä¸­åˆ é™¤ç»™å®šå¯¹è±¡
+ `List() []interface{}`: è¿”å›æ‰€æœ‰å½“å‰éç©ºç´¯åŠ å™¨çš„åˆ—è¡¨
+ `ListKeys() []string`: è¿”å›å½“å‰ä¸éç©ºç´¯åŠ å™¨å…³è”çš„æ‰€æœ‰é”®çš„åˆ—è¡¨
+ `Get(obj interface{}) (item interface{}, exists bool, err error)`: è¿”å›ä¸ç»™å®šå¯¹è±¡çš„é”®ç›¸å…³è”çš„ç´¯åŠ å™¨ä¸­çš„ç´¯åŠ å™¨
+ `GetByKey(key string) (item interface{}, exists bool, err error)`: è¿”å›ä¸ç»™å®šé”®ç›¸å…³è”çš„ç´¯åŠ å™¨
+ `Replace([]interface{}, string) error`: åˆ é™¤å­˜å‚¨ä¸­çš„å†…å®¹ï¼Œä½¿ç”¨ç»™å®šçš„åˆ—è¡¨æ›¿æ¢ã€‚Store è·å–è¯¥åˆ—è¡¨çš„æ‰€æœ‰æƒï¼Œè°ƒç”¨æ­¤å‡½æ•°åä¸åº”å†å¼•ç”¨è¯¥åˆ—è¡¨ã€‚
+ `Resync() error`: åœ¨æ­¤å¤„å‡ºç°çš„æœ¯è¯­ä¸­æ¯«æ— æ„ä¹‰ï¼Œä½†åœ¨æŸäº›å…·æœ‰éå¹³å‡¡é™„åŠ è¡Œä¸ºï¼ˆä¾‹å¦‚ DeltaFIFOï¼‰çš„å®ç°ä¸­å…·æœ‰æ„ä¹‰ã€‚

**åˆ†ç±»ï¼š**

+ `Add(obj interface{}) error`
  + åŠŸèƒ½ï¼šå°†ç»™å®šå¯¹è±¡æ·»åŠ åˆ°ä¸ç»™å®šå¯¹è±¡çš„é”®ç›¸å…³è”çš„ç´¯åŠ å™¨ä¸­
  + å‚æ•°ï¼š
    + objï¼šè¦æ·»åŠ çš„å¯¹è±¡
  + è¿”å›å€¼ï¼šæ— 
+ `Update(obj interface{}) error`
  + åŠŸèƒ½ï¼šæ›´æ–°ä¸ç»™å®šå¯¹è±¡çš„é”®ç›¸å…³è”çš„ç´¯åŠ å™¨ä¸­çš„ç»™å®šå¯¹è±¡
  + å‚æ•°ï¼š
    + objï¼šè¦æ›´æ–°çš„å¯¹è±¡
  + è¿”å›å€¼ï¼šæ— 
+ `Delete(obj interface{}) error`
  + åŠŸèƒ½ï¼šä»ä¸ç»™å®šå¯¹è±¡çš„é”®ç›¸å…³è”çš„ç´¯åŠ å™¨ä¸­åˆ é™¤ç»™å®šå¯¹è±¡
  + å‚æ•°ï¼š
    + objï¼šè¦åˆ é™¤çš„å¯¹è±¡
  + è¿”å›å€¼ï¼šæ— 
+ `List() []interface{}`
  + åŠŸèƒ½ï¼šè¿”å›æ‰€æœ‰å½“å‰éç©ºç´¯åŠ å™¨çš„åˆ—è¡¨
  + å‚æ•°ï¼šæ— 
  + è¿”å›å€¼ï¼šæ‰€æœ‰å½“å‰éç©ºç´¯åŠ å™¨çš„åˆ—è¡¨
+ `ListKeys() []string`
  + åŠŸèƒ½ï¼šè¿”å›å½“å‰ä¸éç©ºç´¯åŠ å™¨å…³è”çš„æ‰€æœ‰é”®çš„åˆ—è¡¨
  + å‚æ•°ï¼šæ— 
  + è¿”å›å€¼ï¼šå½“å‰ä¸éç©ºç´¯åŠ å™¨å…³è”çš„æ‰€æœ‰é”®çš„åˆ—è¡¨
+ `Get(obj interface{}) (item interface{}, exists bool, err error)`
  + åŠŸèƒ½ï¼šè¿”å›ä¸ç»™å®šå¯¹è±¡çš„é”®ç›¸å…³è”çš„ç´¯åŠ å™¨ä¸­çš„ç´¯åŠ å™¨
  + å‚æ•°ï¼š
    + objï¼šè¦è·å–çš„å¯¹è±¡
  + è¿”å›å€¼ï¼š
    + itemï¼šä¸ç»™å®šå¯¹è±¡çš„é”®ç›¸å…³è”çš„ç´¯åŠ å™¨ä¸­çš„ç´¯åŠ å™¨
    + existsï¼šæ˜¯å¦å­˜åœ¨è¯¥ç´¯åŠ å™¨
    + errï¼šé”™è¯¯ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
+ `GetByKey(key string) (item interface{}, exists bool, err error)`
  + åŠŸèƒ½ï¼šè¿”å›ä¸ç»™å®šé”®ç›¸å…³è”çš„ç´¯åŠ å™¨
  + å‚æ•°ï¼š
    + keyï¼šè¦è·å–çš„é”®
  + è¿”å›å€¼ï¼š
    + itemï¼šä¸ç»™å®šé”®ç›¸å…³è”çš„ç´¯åŠ å™¨
    + existsï¼šæ˜¯å¦å­˜åœ¨è¯¥ç´¯åŠ å™¨
    + errï¼šé”™è¯¯ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
+ `Replace([]interface{}, string) error`
  + åŠŸèƒ½ï¼šåˆ é™¤å­˜å‚¨ä¸­çš„å†…å®¹ï¼Œä½¿ç”¨ç»™å®šçš„åˆ—è¡¨æ›¿æ¢ã€‚Store è·å–è¯¥åˆ—è¡¨çš„æ‰€æœ‰æƒï¼Œè°ƒç”¨æ­¤å‡½æ•°åä¸åº”å†å¼•ç”¨è¯¥åˆ—è¡¨ã€‚
  + å‚æ•°ï¼š
    + []interface{}ï¼šè¦æ›¿æ¢çš„åˆ—è¡¨
    + stringï¼šç”¨äºè®°å½•æ—¥å¿—çš„å­—ç¬¦ä¸²
  + è¿”å›å€¼ï¼šé”™è¯¯ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
+ `Resync() error`
  + åŠŸèƒ½ï¼šåœ¨æ­¤å¤„å‡ºç°çš„æœ¯è¯­ä¸­æ¯«æ— æ„ä¹‰ï¼Œä½†åœ¨æŸäº›å…·æœ‰éå¹³å‡¡é™„åŠ è¡Œä¸ºï¼ˆä¾‹å¦‚ DeltaFIFOï¼‰çš„å®ç°ä¸­å…·æœ‰æ„ä¹‰ã€‚
  + å‚æ•°ï¼šæ— 
  + è¿”å›å€¼ï¼šé”™è¯¯ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰



### UndeltaStore

å®ç°äº† `Store` ï¼Œåˆ©ç”¨äº† cache å­˜æ”¾æ•°æ®ï¼Œæ•°æ®å˜æ›´çš„æ—¶å€™é€šè¿‡ PushFunc å‘é€å½“å‰å®Œæ•´çš„çŠ¶æ€ã€‚

```go
type UndeltaStore struct {
	Store
	PushFunc func([]interface{})
}
```

å¯ä»¥çœ‹åˆ° `UndeltaStore` ç»“æ„ä½“åµŒå¥—äº†ä¸€ä¸ªæ¥å£ï¼Œè¿™æ ·åšçš„ç›®çš„æ˜¯å°†æ¥å£çš„æ–¹æ³•ä½œä¸ºç»“æ„ä½“çš„ä¸€éƒ¨åˆ†ï¼Œä»¥ä¾¿æ›´æ–¹ä¾¿åœ°è®¿é—®æ¥å£çš„æ–¹æ³•ã€‚

æ¯”å¦‚è¯´ Add:

```go
func (u *UndeltaStore) Add(obj interface{}) error {
	if err := u.Store.Add(obj); err != nil {
		return err
	}
	u.PushFunc(u.Store.List())
	return nil
}
```



### Heap

Heap é€šè¿‡å®ç° Storeï¼Œåˆ©ç”¨ data æ•°æ®ç»“æ„å­˜æ”¾æ•°æ®ï¼Œå®ç°å †æ•°æ®ç»“æ„ï¼Œç”¨äºä¼˜å…ˆçº§é˜Ÿåˆ—ã€‚

```go
// heapData is an internal struct that implements the standard heap interface
// and keeps the data stored in the heap.
type heapData struct {
	// items is a map from key of the objects to the objects and their index.
	// We depend on the property that items in the map are in the queue and vice versa.
	items map[string]*heapItem
	// queue implements a heap data structure and keeps the order of elements
	// according to the heap invariant. The queue keeps the keys of objects stored
	// in "items".
	queue []string

	// keyFunc is used to make the key used for queued item insertion and retrieval, and
	// should be deterministic.
	keyFunc KeyFunc
	// lessFunc is used to compare two objects in the heap.
	lessFunc LessFunc
}
```







### FIFO

FIFO å®ç°äº† Queue ï¼ˆåŒ…å« Store)ï¼Œåˆ©ç”¨è‡ªå·±å†…éƒ¨çš„ Items æ•°æ®ç»“æ„å­˜æ”¾æ•°æ®ã€‚

```go
// Queue extends Store with a collection of Store keys to "process".
// Every Add, Update, or Delete may put the object's key in that collection.
// A Queue has a way to derive the corresponding key given an accumulator.
// A Queue can be accessed concurrently from multiple goroutines.
// A Queue can be "closed", after which Pop operations return an error.
type Queue interface {
	Store

	// Pop blocks until there is at least one key to process or the
	// Queue is closed.  In the latter case Pop returns with an error.
	// In the former case Pop atomically picks one key to process,
	// removes that (key, accumulator) association from the Store, and
	// processes the accumulator.  Pop returns the accumulator that
	// was processed and the result of processing.  The PopProcessFunc
	// may return an ErrRequeue{inner} and in this case Pop will (a)
	// return that (key, accumulator) association to the Queue as part
	// of the atomic processing and (b) return the inner error from
	// Pop.
	Pop(PopProcessFunc) (interface{}, error)

	// AddIfNotPresent puts the given accumulator into the Queue (in
	// association with the accumulator's key) if and only if that key
	// is not already associated with a non-empty accumulator.
	AddIfNotPresent(interface{}) error

	// HasSynced returns true if the first batch of keys have all been
	// popped.  The first batch of keys are those of the first Replace
	// operation if that happened before any Add, AddIfNotPresent,
	// Update, or Delete; otherwise the first batch is empty.
	HasSynced() bool

	// Close the queue
	Close()
}
```



## DeltaFIFO

æ¥ä¸‹æ¥å°±æ˜¯é‡ç‚¹ DeltaFIFO  çš„éƒ¨åˆ†äº†



### åº”ç”¨åœºæ™¯

**DeltaFIFO çš„ä¸»è¦åº”ç”¨åœºæ™¯å¦‚ä¸‹ï¼š**

+ å½“ä½ å¸Œæœ›å¤„ç†æ¯ä¸€ä¸ªå¯¹è±¡çš„å˜åŒ–æœ€å¤šä¸€æ¬¡
+ å½“ä½ å¤„ç†ä¸€ä¸ªå¯¹è±¡çš„æ—¶å€™ï¼Œå¸Œæœ›çŸ¥é“è¿™ä¸ªå¯¹è±¡ä¸ä½ ä¸Šä¸€æ¬¡å¤„ç†æ—¶ï¼Œå‘ç”Ÿäº†å“ªäº›å˜åŒ–ã€‚
+ å½“ä½ å¸Œæœ›ä¸€ä¸ªå¯¹è±¡åˆ é™¤çš„æ—¶å€™ï¼Œä½ ä»ç„¶èƒ½å¤Ÿå¤„ç†å®ƒ
+ èƒ½å¤Ÿå‘¨æœŸæ€§çš„å¤„ç†æ‰€æœ‰çš„å¯¹è±¡



**ç»“æ„ä½“ï¼š**

`DeltaFIFO`æ˜¯K8sä¸­ç”¨æ¥å­˜å‚¨å¤„ç†æ•°æ®çš„`Queue`ï¼Œç›¸è¾ƒäºä¼ ç»Ÿçš„`FIFO`ï¼Œå®ƒä¸ä»…ä»…å­˜å‚¨äº†æ•°æ®ä¿è¯äº†å…ˆè¿›å…ˆå‡ºï¼Œè€Œä¸”å­˜å‚¨æœ‰K8s èµ„æºå¯¹è±¡çš„ç±»å‹ã€‚å…¶æ˜¯è¿æ¥`Reflector`(ç”Ÿäº§è€…)å’Œ`indexer`(æ¶ˆè´¹è€…)çš„é‡è¦é€šé“ã€‚

```go
type DeltaFIFO struct {
	// lock/cond protects access to 'items' and 'queue'.
	lock sync.RWMutex
	cond sync.Cond

	// `items` maps a key to a Deltas.
	// Each such Deltas has at least one Delta.
	items map[string]Deltas

	// `queue` maintains FIFO order of keys for consumption in Pop().
	// There are no duplicates in `queue`.
	// A key is in `queue` if and only if it is in `items`.
	queue []string

	// populated is true if the first batch of items inserted by Replace() has been populated
	// or Delete/Add/Update/AddIfNotPresent was called first.
	populated bool
	// initialPopulationCount is the number of items inserted by the first call of Replace()
	initialPopulationCount int

	// keyFunc is used to make the key used for queued item
	// insertion and retrieval, and should be deterministic.
	keyFunc KeyFunc

	// knownObjects list keys that are "known" --- affecting Delete(),
	// Replace(), and Resync()
	knownObjects KeyListerGetter

	// Used to indicate a queue is closed so a control loop can exit when a queue is empty.
	// Currently, not used to gate any of CRUD operations.
	closed bool

	// emitDeltaTypeReplaced is whether to emit the Replaced or Sync
	// DeltaType when Replace() is called (to preserve backwards compat).
	emitDeltaTypeReplaced bool

	// Called with every object if non-nil.
	transformer TransformFunc
}
```

ğŸ“œ å¯¹ä¸Šé¢çš„è§£é‡Šï¼š

+ `items` æ˜¯è®¡ç®—çš„ keyï¼Œvalue æ˜¯ä¸€ä¸ª Deltas çš„ç»“æ„ä½“ï¼Œ
+ `queue`ï¼šä¿è¯è¿™ä¸ªé˜Ÿåˆ—çš„é¡ºåºæ€§
+ `keyFunc`ï¼šæˆ‘ä»¬é»˜è®¤ä½¿ç”¨ `<namespce>/<name>` ä¸æŒ‡å®š namespace æ—¶å€™ç”¨ `<name>`
+ `knownObjects` : ä¸“é—¨ç”¨æ¥å­˜æ”¾æ•°æ®çš„åœ°æ–¹ï¼Œå…¶å®å°±æ˜¯ `Indexer`



## äº‹ä»¶çš„ç”Ÿäº§å’Œæ¶ˆè´¹

ä½œä¸ºä¸€ä¸ªä¸­é—´ç®¡é“çš„ä½œç”¨ï¼Œå¯¹åº”çš„ä¸€è¾¹å°±æ˜¯ç”Ÿäº§è€…ï¼Œä¸€éå°±æ˜¯æ¶ˆè´¹è€…ã€‚

### ç”Ÿäº§

+ Reflector çš„ List
+ Reflector çš„ Watch
+ Reflector çš„ Resync



### æ¶ˆè´¹

+ äº‹ä»¶æ´¾å‘åˆ° work queue 
+ åˆ·æ–°æœ¬åœ°ç¼“å­˜



## Indexer

Indexer ä¸»è¦æä¾›äº†ä¸€ä¸ªå¯¹è±¡æ ¹æ®ä¸€å®šæ£€ç´¢èƒ½åŠ›ï¼Œå…¸å‹çš„å®ç°å°±æ˜¯é€šè¿‡ namespace æ¥æ„å»º Keyï¼Œé€šè¿‡ Thread Safe Store æ¥å­˜å‚¨å¯¹è±¡ã€‚





## END é“¾æ¥

<ul><li><div><a href = '68.md' style='float:left'>â¬†ï¸ä¸Šä¸€èŠ‚ğŸ”—  </a><a href = '70.md' style='float: right'>  ï¸ä¸‹ä¸€èŠ‚ğŸ”—</a></div></li></ul>

+ [â“‚ï¸å›åˆ°ç›®å½•ğŸ ](../README.md)

+ [**ğŸ«µå‚ä¸è´¡çŒ®ğŸ’â¤ï¸â€ğŸ”¥ğŸ’–**](https://nsddd.top/archives/contributors))

+ âœ´ï¸ç‰ˆæƒå£°æ˜ &copy; ï¼šæœ¬ä¹¦æ‰€æœ‰å†…å®¹éµå¾ª[CC-BY-SA 3.0åè®®ï¼ˆç½²å-ç›¸åŒæ–¹å¼å…±äº«ï¼‰&copy;](http://zh.wikipedia.org/wiki/Wikipedia:CC-by-sa-3.0åè®®æ–‡æœ¬) 

