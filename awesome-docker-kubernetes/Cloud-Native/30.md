+ [author](http://nsddd.top)

# ç¬¬30èŠ‚  localRegistry's info into a secret in namespace kube-system #2056

<br>

> â¤ï¸ğŸ’•ğŸ’•è®°å½•[sealos](https://github.com/cubxxw/sealos)å¼€æºé¡¹ç›®çš„å­¦ä¹ è¿‡ç¨‹ã€‚[k8s,dockerå’Œäº‘åŸç”Ÿçš„å­¦ä¹ ](https://github.com/cubxxw/sealos)ã€‚Myblog:[http://nsddd.top](http://nsddd.top/)

---
[TOC]

## Issue Description

+ [issues#2056](https://github.com/sealerio/sealer/issues/2056)

Maybe Sealer can dump localRegistry's info into a `secret` in namespace `kube-system`. Some component can use this `secret`.

**Type: *feature request***

**date: *2023-02-21***



## namespace

Three initial namespaces for a clusterï¼š`default`ã€`kube-system` å’Œ `kube-public`ã€‚

+ `Default`:  Used for some deployments that don't specify namespaces, this is a quick way to create messes that can be difficult to clean up if you do a lot of deployments without the right information. I'm not going to touch it because it has only one purpose and has misled me in more than one situation.
+ `Kube-system` : Is the namespace of all objects associated with the Kubernetes system. Any deployment of this namespace can be a dangerous operation that could irreparably damage the system itself. Yes, I've tried; So I don't recommend it.
+ `Kube-public` : It is readable by all (public), but the namespace is reserved for the system.

> ä½ å¥½ï¼Œsealeræ˜¯æ­å»ºKubernetesçš„å·¥å…·ï¼Œç°åœ¨sealeræœ‰ä¸€ä¸ªä»»åŠ¡ï¼Œéœ€è¦å°† localRegistry's info into a `secret` in namespace `kube-system`ï¼ŒSome component can use this `secret`.  
>
> `Kube-system` æ˜¯ Kubernetes ç³»ç»Ÿç›¸å…³çš„æ‰€æœ‰å¯¹è±¡ç»„æˆçš„å‘½åç©ºé—´ã€‚è¯·é—®æˆ‘è¯¥æ€ä¹ˆå®ç°è¿™ä¸ªåŠŸèƒ½
>
> localRegistryçš„ä¿¡æ¯åœ¨å‘½åç©ºé—´kube-systemä¸­å˜æˆäº†ä¸€ä¸ªâ€œç§˜å¯†â€ï¼Œä¸€äº›ç»„ä»¶å¯ä»¥ä½¿ç”¨è¿™ä¸ªâ€œç§˜å¯†â€ã€‚

API é›†ç¾¤é…ç½®æ–‡ä»¶ï¼ˆyamlæ–‡ä»¶ï¼‰

ç«¯å£å¯†ç ï¼Œè½¬å­˜åˆ° System namespace

é»˜è®¤ç”Ÿæˆã€‚

`pkg/cluster-runtime/installer.go`

![be19b04545eacc4fb0a793db36c3cc7a](http://sm.nsddd.top/sm202302211739502.png)



## Registry

There are at least three types of registry, Kubernetes Registry, Docker Registry and container registry. The following are the explanations for these registries:

[maybe u should read this articre](https://betterme.xin/posts/2021-09/k8s04/)

+ **Docker registryï¼š**A Docker registry contains Docker images that you can pull in order to use them in your deployment. The registry is a stateless, scalable server side application that stores and lets you distribute Docker images.
+ **Kubernetes registry**ï¼šThe Kubernetes registry is an image pull secret that your deployment uses to authenticate with a Docker registry.
+ **Container registryï¼š** A container registry is a repositoryâ€”or collection of repositoriesâ€”used to store and access container images.



## Secrets

A Secret is an object that contains a small amount of sensitive data such as a password, a token, or a key. Such information might otherwise be put in a [Pod](https://kubernetes.io/docs/concepts/workloads/pods/) specification or in a [container image](https://kubernetes.io/docs/reference/glossary/?all=true#term-image). Using a Secret means that you don't need to include confidential data in your application code.

Secrets are similar to [ConfigMaps](https://kubernetes.io/docs/concepts/configuration/configmap/) but are specifically intended to hold confidential data.

âš ï¸ Kubernetes Secrets are, by default, stored unencrypted in the API server's underlying data store (etcd). Anyone with API access can retrieve or modify a Secret, and so can anyone with access to etcd. Additionally, anyone who is authorized to create a Pod in a namespace can use that access to read any Secret in that namespace; this includes indirect access such as the ability to create a Deployment.

**In order to safely use Secrets, take at least the following steps:**

1. [Enable Encryption at Rest](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/) for Secrets.
2. Enable or configure RBAC rules](https://kubernetes.io/docs/reference/access-authn-authz/authorization/) with least-privilege access to Secrets.
3. Restrict Secret access to specific containers.
4. [Consider using external Secret store providers](https://secrets-store-csi-driver.sigs.k8s.io/concepts.html#provider-for-the-secrets-store-csi-driver).



**There are several options to create a Secret:**

+ [Use `kubectl`](https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-kubectl/)
+ [Use a configuration file](https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-config-file/)
+ [Use the Kustomize tool](https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-kustomize/)



**æŸ¥çœ‹ namespace ä¸­æ‰€æœ‰ secret å¯¹è±¡ï¼š**

```bash
$ kubectl get secrets -n kube-system
```

> æ‚¨åº”è¯¥èƒ½å¤Ÿçœ‹åˆ°ä¸€ä¸ªåä¸º`<registry-name>-secret`çš„Secretå¯¹è±¡ï¼Œå…¶ä¸­`<registry-name>`æ˜¯æ‚¨åœ¨å®‰è£…Docker Registryæ—¶æŒ‡å®šçš„åç§°ã€‚æ­¤Secretå¯¹è±¡åŒ…å« Docker Registry çš„ç™»å½•å‡­è¯ï¼ŒåŒ…æ‹¬ç”¨æˆ·åå’Œå¯†ç ç­‰ä¿¡æ¯ã€‚æ‚¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤è·å–Secretå¯¹è±¡çš„è¯¦ç»†ä¿¡æ¯ï¼š
>
> ```bash
> $ kubectl describe secret <registry-name>-secret -n kube-system
> ```
>
> å¦‚æœæ‚¨å®‰è£…çš„æ˜¯å…¶ä»–ç±»å‹çš„å®¹å™¨é•œåƒä»“åº“ï¼Œä¾‹å¦‚Harboræˆ–Nexusç­‰ï¼Œé‚£ä¹ˆè¿™äº›å®¹å™¨é•œåƒä»“åº“çš„ä¿¡æ¯å¯èƒ½å­˜å‚¨åœ¨å…¶ä»–ä½ç½®ã€‚



ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹yamlæ–‡ä»¶ï¼Œå…¶ä¸­åŒ…å«äº†ä¸€ä¸ªåä¸º`registry-secret`çš„Secretå¯¹è±¡ï¼Œç”¨äºå­˜å‚¨ `Docker Registry` çš„ç™»å½•å‡­è¯ã€‚è¯·å°†å…¶ä¸­çš„å ä½ç¬¦ï¼ˆ`<registry-url>`ã€`<registry-username>`å’Œ`<registry-password>`ï¼‰æ›¿æ¢ä¸ºæ‚¨çš„Docker Registryçš„URLã€ç”¨æˆ·åå’Œå¯†ç ã€‚

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: registry-secret
  namespace: kube-system
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: eyAiYXV0aCI6ICJodHRwczovL2RvY2tlci5leGFtcGxlLmNvbSIsICJ1c2VybmFtZSI6ICJ1c2VybmFtZSIsICJwYXNzd29yZCI6ICJwYXNzd29yZCJ9Cg==
```

å…¶ä¸­ï¼Œ`data`å­—æ®µä¸­çš„å€¼æ˜¯ä¸€ä¸ªBase64ç¼–ç çš„JSONå­—ç¬¦ä¸²ï¼Œå…¶ä¸­åŒ…å«Docker Registryçš„ç™»å½•å‡­è¯ã€‚æ‚¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å°†Docker Registryçš„ç™»å½•å‡­è¯ç¼–ç ä¸ºBase64å­—ç¬¦ä¸²ï¼š

```bash
echo -n '{"auth": "https://<registry-url>", "username": "<registry-username>", "password": "<registry-password>"}' | base64
```

è¦å°†è¿™ä¸ªyamlæ–‡ä»¶åº”ç”¨åˆ°Kubernetesé›†ç¾¤ä¸­ï¼Œå¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š

```bash
kubectl apply -f registry-secret.yaml
```

è¿™å°†åˆ›å»ºåä¸º`registry-secret`çš„Secretå¯¹è±¡ï¼Œå¹¶å°†å…¶å­˜å‚¨åœ¨kube-systemå‘½åç©ºé—´ä¸­ã€‚å…¶ä»–Kubernetesç»„ä»¶å¯ä»¥ä½¿ç”¨æ­¤Secretå¯¹è±¡ä¸­çš„å‡­è¯æ¥è®¿é—®æ‚¨çš„Docker Registryã€‚



å¦‚æœæ‚¨åœ¨å®‰è£…Kubernetesæ—¶å°†Docker Registryçš„ç™»å½•å‡­è¯å­˜å‚¨åœ¨Secretå¯¹è±¡ä¸­ï¼Œé‚£ä¹ˆæ‚¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ä»Secretå¯¹è±¡ä¸­æå–å‡ºDocker Registryçš„ä¿¡æ¯ï¼š

```bash
kubectl get secret <registry-secret-name> -n kube-system -o jsonpath='{.data.\.dockerconfigjson}' | base64 --decode
```

å…¶ä¸­ï¼Œ`<registry-secret-name>`æ˜¯æ‚¨åœ¨å®‰è£…Kubernetesæ—¶åˆ›å»ºçš„Secretå¯¹è±¡çš„åç§°ã€‚è¿™ä¸ªå‘½ä»¤å°†è¾“å‡ºä¸€ä¸ªJSONå­—ç¬¦ä¸²ï¼Œå…¶ä¸­åŒ…å«Docker Registryçš„URLã€ç”¨æˆ·åå’Œå¯†ç ç­‰ä¿¡æ¯ã€‚



æ‚¨å¯ä»¥ä½¿ç”¨`jq`å‘½ä»¤å¯¹è¿™ä¸ªJSONå­—ç¬¦ä¸²è¿›è¡Œè§£æï¼Œä¾‹å¦‚ï¼š

```go
kubectl get secret <registry-secret-name> -n kube-system -o jsonpath='{.data.\.dockerconfigjson}' | base64 --decode | jq '.auth'
```

è¿™å°†è¾“å‡ºDocker Registryçš„URLï¼Œä¾‹å¦‚ï¼š

```
"https://<registry-url>"
```

æ‚¨å¯ä»¥ä½¿ç”¨ç±»ä¼¼çš„æ–¹å¼æå–å‡ºå…¶ä»–ç™»å½•å‡­è¯ä¿¡æ¯ï¼Œä¾‹å¦‚ç”¨æˆ·åå’Œå¯†ç ï¼š

```bash
kubectl get secret <registry-secret-name> -n kube-system -o jsonpath='{.data.\.dockerconfigjson}' | base64 --decode | jq '.username'
kubectl get secret <registry-secret-name> -n kube-system -o jsonpath='{.data.\.dockerconfigjson}' | base64 --decode | jq '.password'
```



**åˆ›å»º secret å¯¹è±¡ï¼š**

åœ¨`installer.go`ä¸­ï¼Œå¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤åˆ›å»ºä¸€ä¸ªåä¸º`registry-secret`çš„Secretå¯¹è±¡ï¼š

```bash
secret := &corev1.Secret{
    ObjectMeta: metav1.ObjectMeta{
        Name:      "registry-secret",
        Namespace: "kube-system",
    },
    Data: map[string][]byte{
        ".dockerconfigjson": []byte(<registry-login-info>),
    },
    Type: corev1.SecretTypeDockerConfigJson,
}
```

å…¶ä¸­ï¼Œ`<registry-login-info>`æ˜¯ä¸€ä¸ªåŒ…å«Docker Registryçš„ç™»å½•å‡­è¯ä¿¡æ¯çš„JSONå­—ç¬¦ä¸²ã€‚æ‚¨éœ€è¦å°†è¯¥å­—ç¬¦ä¸²å­˜å‚¨åœ¨Sealerä»£ç ä¸­ï¼Œæˆ–ä»å¤–éƒ¨è¯»å–å¹¶ä¼ é€’ç»™Sealerä»£ç ã€‚

 

**å°†Secretå¯¹è±¡ä¿å­˜åˆ°Kubernetesä¸­**

æ¥ä¸‹æ¥ï¼Œå¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å°†ä¸Šè¿°åˆ›å»ºçš„Secretå¯¹è±¡ä¿å­˜åˆ°Kubernetesä¸­ï¼š

```go
_, err = kubeClient.CoreV1().Secrets("kube-system").Create(context.Background(), secret, metav1.CreateOptions{})
if err != nil {
    return err
}
```

è¿™å°†åœ¨`kube-system`å‘½åç©ºé—´ä¸­åˆ›å»ºä¸€ä¸ªåä¸º`registry-secret`çš„Secretå¯¹è±¡ï¼Œå¹¶å°†å…¶å­˜å‚¨åˆ°Kubernetesä¸­ã€‚



**åœ¨éœ€è¦ä½¿ç”¨ç™»å½•å‡­è¯çš„ç»„ä»¶ä¸­å¼•ç”¨Secretå¯¹è±¡**

æœ€åï¼Œæ‚¨å¯ä»¥åœ¨éœ€è¦ä½¿ç”¨Docker Registryçš„ç»„ä»¶ä¸­å¼•ç”¨ä¸Šè¿°åˆ›å»ºçš„Secretå¯¹è±¡ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥å°†ä»¥ä¸‹é…ç½®æ·»åŠ åˆ°Deploymentå¯¹è±¡çš„ `spec.template.spec.containers[].imagePullSecrets` æ•°ç»„ä¸­ï¼š

```json
{
    "name": "registry-secret"
}
```

è¿™å°†ä½¿Kubernetesåœ¨æ‹‰å–Dockeré•œåƒæ—¶ä½¿ç”¨`registry-secret` Secretå¯¹è±¡ä¸­å­˜å‚¨çš„Docker Registryçš„ç™»å½•å‡­è¯ã€‚



## å…³é”®ç›®å½•

```go
func NewInstaller(conf v2.ContainerRuntimeConfig, driver infradriver.InfraDriver) (Installer, error) {
	switch conf.Type {
	case common.Docker, "":
		conf.Type = common.Docker
		ret := &DefaultInstaller{
			rootfs: driver.GetClusterRootfsPath(),
			driver: driver,
			envs:   driver.GetClusterEnv(),
			Info: Info{
				CertsDir:               DefaultDockerCertsDir,
				CRISocket:              DefaultDockerCRISocket,
				ContainerRuntimeConfig: conf,
				ConfigFilePath:         filepath.Join(common.GetHomeDir(), ".docker", DockerConfigFileName),
			},
		}
		ret.Info.CgroupDriver = DefaultCgroupDriver
		if cd, ok := ret.envs[CgroupDriverArg]; ok && cd != nil {
			ret.Info.CgroupDriver = cd.(string)
		}

		return ret, nil
	case common.Containerd:
		ret := &DefaultInstaller{
			rootfs: driver.GetClusterRootfsPath(),
			driver: driver,
			envs:   driver.GetClusterEnv(),
			Info: Info{
				CertsDir:               DefaultContainerdCertsDir,
				CRISocket:              DefaultContainerdCRISocket,
				ContainerRuntimeConfig: conf,
			},
		}
		ret.Info.CgroupDriver = DefaultCgroupDriver
		if cd, ok := ret.envs[CgroupDriverArg]; ok && cd != nil {
			ret.Info.CgroupDriver = cd.(string)
		}

		return ret, nil
	default:
		return nil, fmt.Errorf("invalid container runtime type")
	}
}func NewInstaller(conf v2.ContainerRuntimeConfig, driver infradriver.InfraDriver) (Installer, error) {
	switch conf.Type {
	case common.Docker, "":
		conf.Type = common.Docker
		ret := &DefaultInstaller{
			rootfs: driver.GetClusterRootfsPath(),
			driver: driver,
			envs:   driver.GetClusterEnv(),
			Info: Info{
				CertsDir:               DefaultDockerCertsDir,
				CRISocket:              DefaultDockerCRISocket,
				ContainerRuntimeConfig: conf,
				ConfigFilePath:         filepath.Join(common.GetHomeDir(), ".docker", DockerConfigFileName),
			},
		}
		ret.Info.CgroupDriver = DefaultCgroupDriver
		if cd, ok := ret.envs[CgroupDriverArg]; ok && cd != nil {
			ret.Info.CgroupDriver = cd.(string)
		}

		return ret, nil
	case common.Containerd:
		ret := &DefaultInstaller{
			rootfs: driver.GetClusterRootfsPath(),
			driver: driver,
			envs:   driver.GetClusterEnv(),
			Info: Info{
				CertsDir:               DefaultContainerdCertsDir,
				CRISocket:              DefaultContainerdCRISocket,
				ContainerRuntimeConfig: conf,
			},
		}
		ret.Info.CgroupDriver = DefaultCgroupDriver
		if cd, ok := ret.envs[CgroupDriverArg]; ok && cd != nil {
			ret.Info.CgroupDriver = cd.(string)
		}

		return ret, nil
	default:
		return nil, fmt.Errorf("invalid container runtime type")
	}
}
```

```go
func GetHomeDir() string {
	home, err := homedir.Dir()
	if err != nil {
		return "/root/.docker/config.json"
	}
	return home
}
```



## localregistry

**æ–‡ä»¶ï¼š**

`/root/.sealer/Clusterfile`

```bash
kubectl get cm -n kube-system sealer-clusterfile  -oyaml
```

> è¿™æ˜¯ä¸€ä¸ªåœ¨ Kubernetes é›†ç¾¤ä¸­ä½¿ç”¨çš„å‘½ä»¤ï¼Œå®ƒç”¨äºè·å–åä¸º sealer-clusterfile çš„ ConfigMap çš„ YAML æ ¼å¼ï¼Œè¯¥ ConfigMap ä½äº kube-system å‘½åç©ºé—´ä¸­ã€‚è¾“å‡ºå°†åŒ…æ‹¬ ConfigMap çš„åç§°ã€å‘½åç©ºé—´ã€æ ‡ç­¾å’Œæ•°æ®ã€‚ç”±äºä½¿ç”¨äº† `-oyaml` æ ‡å¿—ï¼Œè¾“å‡ºå°†ä»¥ YAML æ ¼å¼å‘ˆç°ã€‚



**Clusterfile:**

```yaml
apiVersion: sealer.io/v2
kind: Cluster
metadata:
  creationTimestamp: null
  name: my-cluster
spec:
  containerRuntime: {}
  env:
  - LocalRegistryDomain=sea.hub
  - LocalRegistryPort=5000
  - LocalRegistryURL=sea.hub:5000
  - RegistryDomain=sea.hub
  - RegistryPort=5000
  - RegistryURL=sea.hub:5000
  hosts:
  - ips:
    - 192.168.137.133
    roles:
    - master
    ssh: {}
  image: docker.io/sealerio/kubernetes:v1.22.15
  registry:
    localRegistry:
      cert: {}
      domain: sea.hub
      ha: true
      insecure: false
      port: 5000
  ssh:
    pk: /root/.ssh/id_rsa
    port: "22"
    user: root
status: {}
```



## END é“¾æ¥

<ul><li><div><a href = '29.md' style='float:left'>â¬†ï¸ä¸Šä¸€èŠ‚ğŸ”—  </a><a href = '31.md' style='float: right'>  ï¸ä¸‹ä¸€èŠ‚ğŸ”—</a></div></li></ul>

+ [â“‚ï¸å›åˆ°ç›®å½•ğŸ ](../README.md)

+ [**ğŸ«µå‚ä¸è´¡çŒ®ğŸ’â¤ï¸â€ğŸ”¥ğŸ’–**](https://nsddd.top/archives/contributors))

+ âœ´ï¸ç‰ˆæƒå£°æ˜ &copy; ï¼šæœ¬ä¹¦æ‰€æœ‰å†…å®¹éµå¾ª[CC-BY-SA 3.0åè®®ï¼ˆç½²å-ç›¸åŒæ–¹å¼å…±äº«ï¼‰&copy;](http://zh.wikipedia.org/wiki/Wikipedia:CC-by-sa-3.0åè®®æ–‡æœ¬) 
