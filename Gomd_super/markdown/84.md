# 1. æŸ¥è¯¢ç»“æœåå°„ç»“æ„ä½“(mysql)

æœ¬æ–‡è®²è§£çš„å®ä¾‹æ˜¯ä»mysqlæŸ¥è¯¢è¿‡æ¥çš„æ•°æ®å¦‚ä½•åå°„åˆ°ç»“æ„ä½“å­—æ®µ,å…·ä½“å®ç°æ–¹æ³•å¦‚ä¸‹ä»£ç ;

ä»£ç ç›®å½•ï¼š

1129

-common

--common.go //æ˜¯å°è£…çš„ä»£ç 

-main.go //æ˜¯æµ‹è¯•ä»£ç 

ä»£ç çš„å°è£…ï¼š

```go
package common

import (
    "errors"
    "reflect"
    "strconv"
    "time"
)

//æ ¹æ®ç»“æ„ä½“ä¸­sqlæ ‡ç­¾æ˜ å°„æ•°æ®åˆ°ç»“æ„ä½“ä¸­å¹¶ä¸”è½¬æ¢ç±»å‹
func DataToStructByTagSql(data map[string]string, obj interface{}) {
    objValue := reflect.ValueOf(obj).Elem()
    for i := 0; i < objValue.NumField(); i++ {
        //è·å–sqlå¯¹åº”çš„å€¼
        value := data[objValue.Type().Field(i).Tag.Get("sql")]
        //è·å–å¯¹åº”å­—æ®µçš„åç§°
        name := objValue.Type().Field(i).Name
        //è·å–å¯¹åº”å­—æ®µç±»å‹
        structFieldType := objValue.Field(i).Type()
        //è·å–å˜é‡ç±»å‹ï¼Œä¹Ÿå¯ä»¥ç›´æ¥å†™"stringç±»å‹"
        val := reflect.ValueOf(value)
        var err error
        if structFieldType != val.Type() {
            //ç±»å‹è½¬æ¢
            val, err = TypeConversion(value, structFieldType.Name()) //ç±»å‹è½¬æ¢
            if err != nil {

            }
        }
        //è®¾ç½®ç±»å‹å€¼
        objValue.FieldByName(name).Set(val)
    }
}

//ç±»å‹è½¬æ¢
func TypeConversion(value string, ntype string) (reflect.Value, error) {
    if ntype == "string" {
        return reflect.ValueOf(value), nil
    } else if ntype == "time.Time" {
        t, err := time.ParseInLocation("2006-01-02 15:04:05", value, time.Local)
        return reflect.ValueOf(t), err
    } else if ntype == "Time" {
        t, err := time.ParseInLocation("2006-01-02 15:04:05", value, time.Local)
        return reflect.ValueOf(t), err
    } else if ntype == "int" {
        i, err := strconv.Atoi(value)
        return reflect.ValueOf(i), err
    } else if ntype == "int8" {
        i, err := strconv.ParseInt(value, 10, 64)
        return reflect.ValueOf(int8(i)), err
    } else if ntype == "int32" {
        i, err := strconv.ParseInt(value, 10, 64)
        return reflect.ValueOf(int64(i)), err
    } else if ntype == "int64" {
        i, err := strconv.ParseInt(value, 10, 64)
        return reflect.ValueOf(i), err
    } else if ntype == "float32" {
        i, err := strconv.ParseFloat(value, 64)
        return reflect.ValueOf(float32(i)), err
    } else if ntype == "float64" {
        i, err := strconv.ParseFloat(value, 64)
        return reflect.ValueOf(i), err
    }

    //else if .......å¢åŠ å…¶ä»–ä¸€äº›ç±»å‹çš„è½¬æ¢

    return reflect.ValueOf(value), errors.New("æœªçŸ¥çš„ç±»å‹ï¼š" + ntype)
}
```

ä»£ç çš„æµ‹è¯•ï¼š

```go
package main

import (
    "fmt"

    "github.com/student/1129/common"
)

//Product Productå®šä¹‰ä¸€ä¸ªç»“æ„ä½“
type Product struct {
    ID           int64  `json:"id" sql:"id"`
    ProductClass string `json:"ProductClass" sql:"ProductClass"`
    ProductName  string `json:"ProductName" sql:"productName"`
    ProductNum   int64  `json:"ProductNum" sql:"productNum"`
    ProductImage string `json:"ProductImage" sql:"productImage"`
    ProductURL   string `json:"ProductUrl" sql:"productUrl" `
}

func main() {
    //è¿™å—æ˜¯æ¨¡æ‹Ÿmysqlè·å–å•æ¡çš„æ•°æ®åå°„åˆ°ç»“æ„ä½“
    data := map[string]string{"id": "1", "ProductClass": "blog", "productName": "5lmh.com", "productNum": "40", "productImage": "http://www.5lmh.com/", "productUrl": "http://www.5lmh.com/"}
    productResult := &Product{}
    common.DataToStructByTagSql(data, productResult)
    fmt.Println(*productResult)
    //è¿™å—æ˜¯æ¨¡æ‹Ÿmysqlè·å–æ‰€æœ‰çš„æ•°æ®åå°„åˆ°ç»“æ„ä½“
    Alldata := []map[string]string{
        {"id": "1", "ProductClass": "blog", "productName": "5lmh.com", "productNum": "40", "productImage": "http://www.5lmh.com/", "productUrl": "http://www.5lmh.com/"},
        {"id": "2", "ProductClass": "blog", "productName": "5lmh.com", "productNum": "40", "productImage": "http://www.5lmh.com/", "productUrl": "http://www.5lmh.com/"},
    }
    var productArray []*Product
    for _, v := range Alldata {
        Allproduct := &Product{}
        common.DataToStructByTagSql(v, Allproduct)
        productArray = append(productArray, Allproduct)
    }
    for _, vv := range productArray {
        fmt.Println(vv)
    }
}
```

## END é“¾æ¥
<ul><li><div><a href = '83.md' style='float:left'>â¬†ï¸ä¸Šä¸€èŠ‚ğŸ”—</a><a href = '85.md' style='float: right'>â¬‡ï¸ä¸‹ä¸€èŠ‚ğŸ”—</a></div></li></ul>

+ [â“‚ï¸å›åˆ°é¦–é¡µğŸ ](../README.md)

+ [**ğŸ«µå‚ä¸è´¡çŒ®ğŸ’â¤ï¸â€ğŸ”¥ğŸ’–**](https://nsddd.top/archives/contributors))

+ âœ´ï¸ç‰ˆæƒå£°æ˜ &copy; :æœ¬ä¹¦æ‰€æœ‰å†…å®¹éµå¾ª[CC-BY-SA 3.0åè®®ï¼ˆç½²å-ç›¸åŒæ–¹å¼å…±äº«ï¼‰&copy;](http://zh.wikipedia.org/wiki/Wikipedia:CC-by-sa-3.0åè®®æ–‡æœ¬) 

