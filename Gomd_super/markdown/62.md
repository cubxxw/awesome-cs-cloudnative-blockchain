# 1. Context

åœ¨ Go httpåŒ…çš„Serverä¸­ï¼Œæ¯ä¸€ä¸ªè¯·æ±‚åœ¨éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„ goroutine å»å¤„ç†ã€‚è¯·æ±‚å¤„ç†å‡½æ•°é€šå¸¸ä¼šå¯åŠ¨é¢å¤–çš„ goroutine ç”¨æ¥è®¿é—®åç«¯æœåŠ¡ï¼Œæ¯”å¦‚æ•°æ®åº“å’ŒRPCæœåŠ¡ã€‚ç”¨æ¥å¤„ç†ä¸€ä¸ªè¯·æ±‚çš„ goroutine é€šå¸¸éœ€è¦è®¿é—®ä¸€äº›ä¸è¯·æ±‚ç‰¹å®šçš„æ•°æ®ï¼Œæ¯”å¦‚ç»ˆç«¯ç”¨æˆ·çš„èº«ä»½è®¤è¯ä¿¡æ¯ã€éªŒè¯ç›¸å…³çš„tokenã€è¯·æ±‚çš„æˆªæ­¢æ—¶é—´ã€‚ å½“ä¸€ä¸ªè¯·æ±‚è¢«å–æ¶ˆæˆ–è¶…æ—¶æ—¶ï¼Œæ‰€æœ‰ç”¨æ¥å¤„ç†è¯¥è¯·æ±‚çš„ goroutine éƒ½åº”è¯¥è¿…é€Ÿé€€å‡ºï¼Œç„¶åç³»ç»Ÿæ‰èƒ½é‡Šæ”¾è¿™äº› goroutine å ç”¨çš„èµ„æºã€‚

### 1.1.1. ä¸ºä»€ä¹ˆéœ€è¦Context

#### åŸºæœ¬ç¤ºä¾‹

```go
package main

import (
    "fmt"
    "sync"

    "time"
)

var wg sync.WaitGroup

// åˆå§‹çš„ä¾‹å­

func worker() {
    for {
        fmt.Println("worker")
        time.Sleep(time.Second)
    }
    // å¦‚ä½•æ¥æ”¶å¤–éƒ¨å‘½ä»¤å®ç°é€€å‡º
    wg.Done()
}

func main() {
    wg.Add(1)
    go worker()
    // å¦‚ä½•ä¼˜é›…çš„å®ç°ç»“æŸå­goroutine
    wg.Wait()
    fmt.Println("over")
}
```

#### å…¨å±€å˜é‡æ–¹å¼

```go
package main

import (
    "fmt"
    "sync"

    "time"
)

var wg sync.WaitGroup
var exit bool

// å…¨å±€å˜é‡æ–¹å¼å­˜åœ¨çš„é—®é¢˜ï¼š
// 1. ä½¿ç”¨å…¨å±€å˜é‡åœ¨è·¨åŒ…è°ƒç”¨æ—¶ä¸å®¹æ˜“ç»Ÿä¸€
// 2. å¦‚æœworkerä¸­å†å¯åŠ¨goroutineï¼Œå°±ä¸å¤ªå¥½æ§åˆ¶äº†ã€‚

func worker() {
    for {
        fmt.Println("worker")
        time.Sleep(time.Second)
        if exit {
            break
        }
    }
    wg.Done()
}

func main() {
    wg.Add(1)
    go worker()
    time.Sleep(time.Second * 3) // sleep3ç§’ä»¥å…ç¨‹åºè¿‡å¿«é€€å‡º
    exit = true                 // ä¿®æ”¹å…¨å±€å˜é‡å®ç°å­goroutineçš„é€€å‡º
    wg.Wait()
    fmt.Println("over")
}
```

#### é€šé“æ–¹å¼

```go
package main

import (
    "fmt"
    "sync"

    "time"
)

var wg sync.WaitGroup

// ç®¡é“æ–¹å¼å­˜åœ¨çš„é—®é¢˜ï¼š
// 1. ä½¿ç”¨å…¨å±€å˜é‡åœ¨è·¨åŒ…è°ƒç”¨æ—¶ä¸å®¹æ˜“å®ç°è§„èŒƒå’Œç»Ÿä¸€ï¼Œéœ€è¦ç»´æŠ¤ä¸€ä¸ªå…±ç”¨çš„channel

func worker(exitChan chan struct{}) {
LOOP:
    for {
        fmt.Println("worker")
        time.Sleep(time.Second)
        select {
        case <-exitChan: // ç­‰å¾…æ¥æ”¶ä¸Šçº§é€šçŸ¥
            break LOOP
        default:
        }
    }
    wg.Done()
}

func main() {
    var exitChan = make(chan struct{})
    wg.Add(1)
    go worker(exitChan)
    time.Sleep(time.Second * 3) // sleep3ç§’ä»¥å…ç¨‹åºè¿‡å¿«é€€å‡º
    exitChan <- struct{}{}      // ç»™å­goroutineå‘é€é€€å‡ºä¿¡å·
    close(exitChan)
    wg.Wait()
    fmt.Println("over")
}
```

#### å®˜æ–¹ç‰ˆçš„æ–¹æ¡ˆ

```go
package main

import (
    "context"
    "fmt"
    "sync"

    "time"
)

var wg sync.WaitGroup

func worker(ctx context.Context) {
LOOP:
    for {
        fmt.Println("worker")
        time.Sleep(time.Second)
        select {
        case <-ctx.Done(): // ç­‰å¾…ä¸Šçº§é€šçŸ¥
            break LOOP
        default:
        }
    }
    wg.Done()
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    wg.Add(1)
    go worker(ctx)
    time.Sleep(time.Second * 3)
    cancel() // é€šçŸ¥å­goroutineç»“æŸ
    wg.Wait()
    fmt.Println("over")
}
```

å½“å­goroutineåˆå¼€å¯å¦å¤–ä¸€ä¸ªgoroutineæ—¶ï¼Œåªéœ€è¦å°†ctxä¼ å…¥å³å¯ï¼š

```go
package main

import (
    "context"
    "fmt"
    "sync"

    "time"
)

var wg sync.WaitGroup

func worker(ctx context.Context) {
    go worker2(ctx)
LOOP:
    for {
        fmt.Println("worker")
        time.Sleep(time.Second)
        select {
        case <-ctx.Done(): // ç­‰å¾…ä¸Šçº§é€šçŸ¥
            break LOOP
        default:
        }
    }
    wg.Done()
}

func worker2(ctx context.Context) {
LOOP:
    for {
        fmt.Println("worker2")
        time.Sleep(time.Second)
        select {
        case <-ctx.Done(): // ç­‰å¾…ä¸Šçº§é€šçŸ¥
            break LOOP
        default:
        }
    }
}
func main() {
    ctx, cancel := context.WithCancel(context.Background())
    wg.Add(1)
    go worker(ctx)
    time.Sleep(time.Second * 3)
    cancel() // é€šçŸ¥å­goroutineç»“æŸ
    wg.Wait()
    fmt.Println("over")
}
```

### 1.1.2. Contextåˆè¯†

Go1.7åŠ å…¥äº†ä¸€ä¸ªæ–°çš„æ ‡å‡†åº“contextï¼Œå®ƒå®šä¹‰äº†Contextç±»å‹ï¼Œä¸“é—¨ç”¨æ¥ç®€åŒ– å¯¹äºå¤„ç†å•ä¸ªè¯·æ±‚çš„å¤šä¸ª goroutine ä¹‹é—´ä¸è¯·æ±‚åŸŸçš„æ•°æ®ã€å–æ¶ˆä¿¡å·ã€æˆªæ­¢æ—¶é—´ç­‰ç›¸å…³æ“ä½œï¼Œè¿™äº›æ“ä½œå¯èƒ½æ¶‰åŠå¤šä¸ª API è°ƒç”¨ã€‚

å¯¹æœåŠ¡å™¨ä¼ å…¥çš„è¯·æ±‚åº”è¯¥åˆ›å»ºä¸Šä¸‹æ–‡ï¼Œè€Œå¯¹æœåŠ¡å™¨çš„ä¼ å‡ºè°ƒç”¨åº”è¯¥æ¥å—ä¸Šä¸‹æ–‡ã€‚å®ƒä»¬ä¹‹é—´çš„å‡½æ•°è°ƒç”¨é“¾å¿…é¡»ä¼ é€’ä¸Šä¸‹æ–‡ï¼Œæˆ–è€…å¯ä»¥ä½¿ç”¨WithCancelã€WithDeadlineã€WithTimeoutæˆ–WithValueåˆ›å»ºçš„æ´¾ç”Ÿä¸Šä¸‹æ–‡ã€‚å½“ä¸€ä¸ªä¸Šä¸‹æ–‡è¢«å–æ¶ˆæ—¶ï¼Œå®ƒæ´¾ç”Ÿçš„æ‰€æœ‰ä¸Šä¸‹æ–‡ä¹Ÿè¢«å–æ¶ˆã€‚

### 1.1.3. Contextæ¥å£

context.Contextæ˜¯ä¸€ä¸ªæ¥å£ï¼Œè¯¥æ¥å£å®šä¹‰äº†å››ä¸ªéœ€è¦å®ç°çš„æ–¹æ³•ã€‚å…·ä½“ç­¾åå¦‚ä¸‹ï¼š

```go
type Context interface {
    Deadline() (deadline time.Time, ok bool)
    Done() <-chan struct{}
    Err() error
    Value(key interface{}) interface{}
}
```

å…¶ä¸­ï¼š

- Deadlineæ–¹æ³•éœ€è¦è¿”å›å½“å‰Contextè¢«å–æ¶ˆçš„æ—¶é—´ï¼Œä¹Ÿå°±æ˜¯å®Œæˆå·¥ä½œçš„æˆªæ­¢æ—¶é—´ï¼ˆdeadlineï¼‰ï¼›
- Doneæ–¹æ³•éœ€è¦è¿”å›ä¸€ä¸ªChannelï¼Œè¿™ä¸ªChannelä¼šåœ¨å½“å‰å·¥ä½œå®Œæˆæˆ–è€…ä¸Šä¸‹æ–‡è¢«å–æ¶ˆä¹‹åå…³é—­ï¼Œå¤šæ¬¡è°ƒç”¨Doneæ–¹æ³•ä¼šè¿”å›åŒä¸€ä¸ªChannelï¼›
- Erræ–¹æ³•ä¼šè¿”å›å½“å‰Contextç»“æŸçš„åŸå› ï¼Œå®ƒåªä¼šåœ¨Doneè¿”å›çš„Channelè¢«å…³é—­æ—¶æ‰ä¼šè¿”å›éç©ºçš„å€¼ï¼›
  - å¦‚æœå½“å‰Contextè¢«å–æ¶ˆå°±ä¼šè¿”å›Canceledé”™è¯¯ï¼›
  - å¦‚æœå½“å‰Contextè¶…æ—¶å°±ä¼šè¿”å›DeadlineExceededé”™è¯¯ï¼›
- Valueæ–¹æ³•ä¼šä»Contextä¸­è¿”å›é”®å¯¹åº”çš„å€¼ï¼Œå¯¹äºåŒä¸€ä¸ªä¸Šä¸‹æ–‡æ¥è¯´ï¼Œå¤šæ¬¡è°ƒç”¨Value å¹¶ä¼ å…¥ç›¸åŒçš„Keyä¼šè¿”å›ç›¸åŒçš„ç»“æœï¼Œè¯¥æ–¹æ³•ä»…ç”¨äºä¼ é€’è·¨APIå’Œè¿›ç¨‹é—´è·Ÿè¯·æ±‚åŸŸçš„æ•°æ®ï¼›

### 1.1.4. Background()å’ŒTODO()

Goå†…ç½®ä¸¤ä¸ªå‡½æ•°ï¼šBackground()å’ŒTODO()ï¼Œè¿™ä¸¤ä¸ªå‡½æ•°åˆ†åˆ«è¿”å›ä¸€ä¸ªå®ç°äº†Contextæ¥å£çš„backgroundå’Œtodoã€‚æˆ‘ä»¬ä»£ç ä¸­æœ€å¼€å§‹éƒ½æ˜¯ä»¥è¿™ä¸¤ä¸ªå†…ç½®çš„ä¸Šä¸‹æ–‡å¯¹è±¡ä½œä¸ºæœ€é¡¶å±‚çš„partent contextï¼Œè¡ç”Ÿå‡ºæ›´å¤šçš„å­ä¸Šä¸‹æ–‡å¯¹è±¡ã€‚

Background()ä¸»è¦ç”¨äºmainå‡½æ•°ã€åˆå§‹åŒ–ä»¥åŠæµ‹è¯•ä»£ç ä¸­ï¼Œä½œä¸ºContextè¿™ä¸ªæ ‘ç»“æ„çš„æœ€é¡¶å±‚çš„Contextï¼Œä¹Ÿå°±æ˜¯æ ¹Contextã€‚

TODO()ï¼Œå®ƒç›®å‰è¿˜ä¸çŸ¥é“å…·ä½“çš„ä½¿ç”¨åœºæ™¯ï¼Œå¦‚æœæˆ‘ä»¬ä¸çŸ¥é“è¯¥ä½¿ç”¨ä»€ä¹ˆContextçš„æ—¶å€™ï¼Œå¯ä»¥ä½¿ç”¨è¿™ä¸ªã€‚

backgroundå’Œtodoæœ¬è´¨ä¸Šéƒ½æ˜¯emptyCtxç»“æ„ä½“ç±»å‹ï¼Œæ˜¯ä¸€ä¸ªä¸å¯å–æ¶ˆï¼Œæ²¡æœ‰è®¾ç½®æˆªæ­¢æ—¶é—´ï¼Œæ²¡æœ‰æºå¸¦ä»»ä½•å€¼çš„Contextã€‚

### 1.1.5. Withç³»åˆ—å‡½æ•°

æ­¤å¤–ï¼ŒcontextåŒ…ä¸­è¿˜å®šä¹‰äº†å››ä¸ªWithç³»åˆ—å‡½æ•°ã€‚

### 1.1.6. WithCancel

WithCancelçš„å‡½æ•°ç­¾åå¦‚ä¸‹ï¼š

```
    func WithCancel(parent Context) (ctx Context, cancel CancelFunc)
```

WithCancelè¿”å›å¸¦æœ‰æ–°Doneé€šé“çš„çˆ¶èŠ‚ç‚¹çš„å‰¯æœ¬ã€‚å½“è°ƒç”¨è¿”å›çš„cancelå‡½æ•°æˆ–å½“å…³é—­çˆ¶ä¸Šä¸‹æ–‡çš„Doneé€šé“æ—¶ï¼Œå°†å…³é—­è¿”å›ä¸Šä¸‹æ–‡çš„Doneé€šé“ï¼Œæ— è®ºå…ˆå‘ç”Ÿä»€ä¹ˆæƒ…å†µã€‚

å–æ¶ˆæ­¤ä¸Šä¸‹æ–‡å°†é‡Šæ”¾ä¸å…¶å…³è”çš„èµ„æºï¼Œå› æ­¤ä»£ç åº”è¯¥åœ¨æ­¤ä¸Šä¸‹æ–‡ä¸­è¿è¡Œçš„æ“ä½œå®Œæˆåç«‹å³è°ƒç”¨cancelã€‚

```go
func gen(ctx context.Context) <-chan int {
        dst := make(chan int)
        n := 1
        go func() {
            for {
                select {
                case <-ctx.Done():
                    return // returnç»“æŸè¯¥goroutineï¼Œé˜²æ­¢æ³„éœ²
                case dst <- n:
                    n++
                }
            }
        }()
        return dst
    }
func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel() // å½“æˆ‘ä»¬å–å®Œéœ€è¦çš„æ•´æ•°åè°ƒç”¨cancel

    for n := range gen(ctx) {
        fmt.Println(n)
        if n == 5 {
            break
        }
    }
}
```

ä¸Šé¢çš„ç¤ºä¾‹ä»£ç ä¸­ï¼Œgenå‡½æ•°åœ¨å•ç‹¬çš„goroutineä¸­ç”Ÿæˆæ•´æ•°å¹¶å°†å®ƒä»¬å‘é€åˆ°è¿”å›çš„é€šé“ã€‚ gençš„è°ƒç”¨è€…åœ¨ä½¿ç”¨ç”Ÿæˆçš„æ•´æ•°ä¹‹åéœ€è¦å–æ¶ˆä¸Šä¸‹æ–‡ï¼Œä»¥å…genå¯åŠ¨çš„å†…éƒ¨goroutineå‘ç”Ÿæ³„æ¼ã€‚

### 1.1.7. WithDeadline

WithDeadlineçš„å‡½æ•°ç­¾åå¦‚ä¸‹ï¼š

```
func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)
```

è¿”å›çˆ¶ä¸Šä¸‹æ–‡çš„å‰¯æœ¬ï¼Œå¹¶å°†deadlineè°ƒæ•´ä¸ºä¸è¿Ÿäºdã€‚å¦‚æœçˆ¶ä¸Šä¸‹æ–‡çš„deadlineå·²ç»æ—©äºdï¼Œåˆ™WithDeadline(parent, d)åœ¨è¯­ä¹‰ä¸Šç­‰åŒäºçˆ¶ä¸Šä¸‹æ–‡ã€‚å½“æˆªæ­¢æ—¥è¿‡æœŸæ—¶ï¼Œå½“è°ƒç”¨è¿”å›çš„cancelå‡½æ•°æ—¶ï¼Œæˆ–è€…å½“çˆ¶ä¸Šä¸‹æ–‡çš„Doneé€šé“å…³é—­æ—¶ï¼Œè¿”å›ä¸Šä¸‹æ–‡çš„Doneé€šé“å°†è¢«å…³é—­ï¼Œä»¥æœ€å…ˆå‘ç”Ÿçš„æƒ…å†µä¸ºå‡†ã€‚

å–æ¶ˆæ­¤ä¸Šä¸‹æ–‡å°†é‡Šæ”¾ä¸å…¶å…³è”çš„èµ„æºï¼Œå› æ­¤ä»£ç åº”è¯¥åœ¨æ­¤ä¸Šä¸‹æ–‡ä¸­è¿è¡Œçš„æ“ä½œå®Œæˆåç«‹å³è°ƒç”¨cancelã€‚

```go
func main() {
    d := time.Now().Add(50 * time.Millisecond)
    ctx, cancel := context.WithDeadline(context.Background(), d)

    // å°½ç®¡ctxä¼šè¿‡æœŸï¼Œä½†åœ¨ä»»ä½•æƒ…å†µä¸‹è°ƒç”¨å®ƒçš„cancelå‡½æ•°éƒ½æ˜¯å¾ˆå¥½çš„å®è·µã€‚
    // å¦‚æœä¸è¿™æ ·åšï¼Œå¯èƒ½ä¼šä½¿ä¸Šä¸‹æ–‡åŠå…¶çˆ¶ç±»å­˜æ´»çš„æ—¶é—´è¶…è¿‡å¿…è¦çš„æ—¶é—´ã€‚
    defer cancel()

    select {
    case <-time.After(1 * time.Second):
        fmt.Println("overslept")
    case <-ctx.Done():
        fmt.Println(ctx.Err())
    }
}
```

ä¸Šé¢çš„ä»£ç ä¸­ï¼Œå®šä¹‰äº†ä¸€ä¸ª50æ¯«ç§’ä¹‹åè¿‡æœŸçš„deadlineï¼Œç„¶åæˆ‘ä»¬è°ƒç”¨context.WithDeadline(context.Background(), d)å¾—åˆ°ä¸€ä¸ªä¸Šä¸‹æ–‡ï¼ˆctxï¼‰å’Œä¸€ä¸ªå–æ¶ˆå‡½æ•°ï¼ˆcancelï¼‰ï¼Œç„¶åä½¿ç”¨ä¸€ä¸ªselectè®©ä¸»ç¨‹åºé™·å…¥ç­‰å¾…ï¼šç­‰å¾…1ç§’åæ‰“å°overslepté€€å‡ºæˆ–è€…ç­‰å¾…ctxè¿‡æœŸåé€€å‡ºã€‚ å› ä¸ºctx50ç§’åå°±è¿‡æœŸï¼Œæ‰€ä»¥ctx.Done()ä¼šå…ˆæ¥æ”¶åˆ°å€¼ï¼Œä¸Šé¢çš„ä»£ç ä¼šæ‰“å°ctx.Err()å–æ¶ˆåŸå› ã€‚

### 1.1.8. WithTimeout

WithTimeoutçš„å‡½æ•°ç­¾åå¦‚ä¸‹ï¼š

```
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
```

WithTimeoutè¿”å›WithDeadline(parent, time.Now().Add(timeout))ã€‚

å–æ¶ˆæ­¤ä¸Šä¸‹æ–‡å°†é‡Šæ”¾ä¸å…¶ç›¸å…³çš„èµ„æºï¼Œå› æ­¤ä»£ç åº”è¯¥åœ¨æ­¤ä¸Šä¸‹æ–‡ä¸­è¿è¡Œçš„æ“ä½œå®Œæˆåç«‹å³è°ƒç”¨cancelï¼Œé€šå¸¸ç”¨äºæ•°æ®åº“æˆ–è€…ç½‘ç»œè¿æ¥çš„è¶…æ—¶æ§åˆ¶ã€‚å…·ä½“ç¤ºä¾‹å¦‚ä¸‹ï¼š

```go
package main

import (
    "context"
    "fmt"
    "sync"

    "time"
)

// context.WithTimeout

var wg sync.WaitGroup

func worker(ctx context.Context) {
LOOP:
    for {
        fmt.Println("db connecting ...")
        time.Sleep(time.Millisecond * 10) // å‡è®¾æ­£å¸¸è¿æ¥æ•°æ®åº“è€—æ—¶10æ¯«ç§’
        select {
        case <-ctx.Done(): // 50æ¯«ç§’åè‡ªåŠ¨è°ƒç”¨
            break LOOP
        default:
        }
    }
    fmt.Println("worker done!")
    wg.Done()
}

func main() {
    // è®¾ç½®ä¸€ä¸ª50æ¯«ç§’çš„è¶…æ—¶
    ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*50)
    wg.Add(1)
    go worker(ctx)
    time.Sleep(time.Second * 5)
    cancel() // é€šçŸ¥å­goroutineç»“æŸ
    wg.Wait()
    fmt.Println("over")
}
```

### 1.1.9. WithValue

WithValueå‡½æ•°èƒ½å¤Ÿå°†è¯·æ±‚ä½œç”¨åŸŸçš„æ•°æ®ä¸ Context å¯¹è±¡å»ºç«‹å…³ç³»ã€‚å£°æ˜å¦‚ä¸‹ï¼š

```
    func WithValue(parent Context, key, val interface{}) Context
```

WithValueè¿”å›çˆ¶èŠ‚ç‚¹çš„å‰¯æœ¬ï¼Œå…¶ä¸­ä¸keyå…³è”çš„å€¼ä¸ºvalã€‚

ä»…å¯¹APIå’Œè¿›ç¨‹é—´ä¼ é€’è¯·æ±‚åŸŸçš„æ•°æ®ä½¿ç”¨ä¸Šä¸‹æ–‡å€¼ï¼Œè€Œä¸æ˜¯ä½¿ç”¨å®ƒæ¥ä¼ é€’å¯é€‰å‚æ•°ç»™å‡½æ•°ã€‚

æ‰€æä¾›çš„é”®å¿…é¡»æ˜¯å¯æ¯”è¾ƒçš„ï¼Œå¹¶ä¸”ä¸åº”è¯¥æ˜¯stringç±»å‹æˆ–ä»»ä½•å…¶ä»–å†…ç½®ç±»å‹ï¼Œä»¥é¿å…ä½¿ç”¨ä¸Šä¸‹æ–‡åœ¨åŒ…ä¹‹é—´å‘ç”Ÿå†²çªã€‚WithValueçš„ç”¨æˆ·åº”è¯¥ä¸ºé”®å®šä¹‰è‡ªå·±çš„ç±»å‹ã€‚ä¸ºäº†é¿å…åœ¨åˆ†é…ç»™interface{}æ—¶è¿›è¡Œåˆ†é…ï¼Œä¸Šä¸‹æ–‡é”®é€šå¸¸å…·æœ‰å…·ä½“ç±»å‹struct{}ã€‚æˆ–è€…ï¼Œå¯¼å‡ºçš„ä¸Šä¸‹æ–‡å…³é”®å˜é‡çš„é™æ€ç±»å‹åº”è¯¥æ˜¯æŒ‡é’ˆæˆ–æ¥å£ã€‚

```go
package main

import (
    "context"
    "fmt"
    "sync"

    "time"
)

// context.WithValue

type TraceCode string

var wg sync.WaitGroup

func worker(ctx context.Context) {
    key := TraceCode("TRACE_CODE")
    traceCode, ok := ctx.Value(key).(string) // åœ¨å­goroutineä¸­è·å–trace code
    if !ok {
        fmt.Println("invalid trace code")
    }
LOOP:
    for {
        fmt.Printf("worker, trace code:%s\n", traceCode)
        time.Sleep(time.Millisecond * 10) // å‡è®¾æ­£å¸¸è¿æ¥æ•°æ®åº“è€—æ—¶10æ¯«ç§’
        select {
        case <-ctx.Done(): // 50æ¯«ç§’åè‡ªåŠ¨è°ƒç”¨
            break LOOP
        default:
        }
    }
    fmt.Println("worker done!")
    wg.Done()
}

func main() {
    // è®¾ç½®ä¸€ä¸ª50æ¯«ç§’çš„è¶…æ—¶
    ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*50)
    // åœ¨ç³»ç»Ÿçš„å…¥å£ä¸­è®¾ç½®trace codeä¼ é€’ç»™åç»­å¯åŠ¨çš„goroutineå®ç°æ—¥å¿—æ•°æ®èšåˆ
    ctx = context.WithValue(ctx, TraceCode("TRACE_CODE"), "12512312234")
    wg.Add(1)
    go worker(ctx)
    time.Sleep(time.Second * 5)
    cancel() // é€šçŸ¥å­goroutineç»“æŸ
    wg.Wait()
    fmt.Println("over")
}
```

### 1.1.10. ä½¿ç”¨Contextçš„æ³¨æ„äº‹é¡¹

- æ¨èä»¥å‚æ•°çš„æ–¹å¼æ˜¾ç¤ºä¼ é€’Context
- ä»¥Contextä½œä¸ºå‚æ•°çš„å‡½æ•°æ–¹æ³•ï¼Œåº”è¯¥æŠŠContextä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ã€‚
- ç»™ä¸€ä¸ªå‡½æ•°æ–¹æ³•ä¼ é€’Contextçš„æ—¶å€™ï¼Œä¸è¦ä¼ é€’nilï¼Œå¦‚æœä¸çŸ¥é“ä¼ é€’ä»€ä¹ˆï¼Œå°±ä½¿ç”¨context.TODO()
- Contextçš„Valueç›¸å…³æ–¹æ³•åº”è¯¥ä¼ é€’è¯·æ±‚åŸŸçš„å¿…è¦æ•°æ®ï¼Œä¸åº”è¯¥ç”¨äºä¼ é€’å¯é€‰å‚æ•°
- Contextæ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå¯ä»¥æ”¾å¿ƒçš„åœ¨å¤šä¸ªgoroutineä¸­ä¼ é€’

### 1.1.11. å®¢æˆ·ç«¯è¶…æ—¶å–æ¶ˆç¤ºä¾‹

è°ƒç”¨æœåŠ¡ç«¯APIæ—¶å¦‚ä½•åœ¨å®¢æˆ·ç«¯å®ç°è¶…æ—¶æ§åˆ¶ï¼Ÿ

### 1.1.12. serverç«¯

```go
// context_timeout/server/main.go
package main

import (
    "fmt"
    "math/rand"
    "net/http"

    "time"
)

// serverç«¯ï¼Œéšæœºå‡ºç°æ…¢å“åº”

func indexHandler(w http.ResponseWriter, r *http.Request) {
    number := rand.Intn(2)
    if number == 0 {
        time.Sleep(time.Second * 10) // è€—æ—¶10ç§’çš„æ…¢å“åº”
        fmt.Fprintf(w, "slow response")
        return
    }
    fmt.Fprint(w, "quick response")
}

func main() {
    http.HandleFunc("/", indexHandler)
    err := http.ListenAndServe(":8000", nil)
    if err != nil {
        panic(err)
    }
}
```

clientç«¯

```go
// context_timeout/client/main.go
package main

import (
    "context"
    "fmt"
    "io/ioutil"
    "net/http"
    "sync"
    "time"
)

// å®¢æˆ·ç«¯

type respData struct {
    resp *http.Response
    err  error
}

func doCall(ctx context.Context) {
    transport := http.Transport{
       // è¯·æ±‚é¢‘ç¹å¯å®šä¹‰å…¨å±€çš„clientå¯¹è±¡å¹¶å¯ç”¨é•¿é“¾æ¥
       // è¯·æ±‚ä¸é¢‘ç¹ä½¿ç”¨çŸ­é“¾æ¥
       DisableKeepAlives: true,     }
    client := http.Client{
        Transport: &transport,
    }

    respChan := make(chan *respData, 1)
    req, err := http.NewRequest("GET", "http://127.0.0.1:8000/", nil)
    if err != nil {
        fmt.Printf("new requestg failed, err:%v\n", err)
        return
    }
    req = req.WithContext(ctx) // ä½¿ç”¨å¸¦è¶…æ—¶çš„ctxåˆ›å»ºä¸€ä¸ªæ–°çš„client request
    var wg sync.WaitGroup
    wg.Add(1)
    defer wg.Wait()
    go func() {
        resp, err := client.Do(req)
        fmt.Printf("client.do resp:%v, err:%v\n", resp, err)
        rd := &respData{
            resp: resp,
            err:  err,
        }
        respChan <- rd
        wg.Done()
    }()

    select {
    case <-ctx.Done():
        //transport.CancelRequest(req)
        fmt.Println("call api timeout")
    case result := <-respChan:
        fmt.Println("call server api success")
        if result.err != nil {
            fmt.Printf("call server api failed, err:%v\n", result.err)
            return
        }
        defer result.resp.Body.Close()
        data, _ := ioutil.ReadAll(result.resp.Body)
        fmt.Printf("resp:%v\n", string(data))
    }
}

func main() {
    // å®šä¹‰ä¸€ä¸ª100æ¯«ç§’çš„è¶…æ—¶
    ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*100)
    defer cancel() // è°ƒç”¨cancelé‡Šæ”¾å­goroutineèµ„æº
    doCall(ctx)
}
```

## END é“¾æ¥
<ul><li><div><a href = '61.md' style='float:left'>â¬†ï¸ä¸Šä¸€èŠ‚ğŸ”—</a><a href = '63.md' style='float: right'>â¬‡ï¸ä¸‹ä¸€èŠ‚ğŸ”—</a></div></li></ul>

+ [â“‚ï¸å›åˆ°é¦–é¡µğŸ ](../README.md)

+ [**ğŸ«µå‚ä¸è´¡çŒ®ğŸ’â¤ï¸â€ğŸ”¥ğŸ’–**](https://nsddd.top/archives/contributors))

+ âœ´ï¸ç‰ˆæƒå£°æ˜ &copy; :æœ¬ä¹¦æ‰€æœ‰å†…å®¹éµå¾ª[CC-BY-SA 3.0åè®®ï¼ˆç½²å-ç›¸åŒæ–¹å¼å…±äº«ï¼‰&copy;](http://zh.wikipedia.org/wiki/Wikipedia:CC-by-sa-3.0åè®®æ–‡æœ¬) 

