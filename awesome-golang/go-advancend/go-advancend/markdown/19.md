+ [author](https://github.com/3293172751)

# ç¬¬19èŠ‚ go å®ç° ping

+ [å›åˆ°ç›®å½•](../README.md)
+ [ä¸Šä¸€èŠ‚](18.md)
> â¤ï¸ğŸ’•ğŸ’•Goè¯­è¨€é«˜çº§ç¯‡ç« ,åœ¨æ­¤ä¹‹å‰å»ºè®®æ‚¨å…ˆäº†è§£åŸºç¡€å’Œè¿›é˜¶ç¯‡ã€‚Myblog:[http://nsddd.top](http://nsddd.top/)
> ###  **[Goè¯­è¨€åŸºç¡€ç¯‡](https://github.com/3293172751/Block_Chain/blob/master/TOC.md)**
>
> ###  **[Goè¯­è¨€100ç¯‡è¿›é˜¶](https://github.com/3293172751/Block_Chain/blob/master/Gomd_super/README.md)**
---
[TOC]

## ICMP

### ICMPã¨ã¯ï¼Ÿ

1. ICMPï¼ˆäº’è”ç½‘æ§åˆ¶æ¶ˆæ¯åè®®ï¼‰æ˜¯ IP åè®®çš„â€œé”™è¯¯é€šçŸ¥â€å’Œâ€œæ§åˆ¶æ¶ˆæ¯â€
2. ç”¨äºä¼ è¾“ çš„åè®®ã€‚ æ£€æŸ¥å®ç° TCP/IP çš„è®¡ç®—æœºä¹‹é—´çš„é€šä¿¡çŠ¶æ€
3. ä½¿ç”¨ã€‚ ICMP æ˜¯ä¸€ç§åœ¨äº’è”ç½‘å±‚ï¼ˆOSI å‚è€ƒæ¨¡å‹çš„ç½‘ç»œå±‚ï¼‰ä¸Šè¿è¡Œçš„åè®®ã€‚



::: tip æ¨è ICMP çš„åŠŸèƒ½ä¸ä½¿ç”¨

+ [https://github.com/cubxxw/cs-awesome-Block_Chain/blob/master/web/markdown/20.md](https://github.com/cubxxw/cs-awesome-Block_Chain/blob/master/web/markdown/20.md)

:::



### æŠ¥æ–‡å¤´

ICMPæŠ¥å¤´ä»IPæŠ¥å¤´çš„ç¬¬160ä½å¼€å§‹ï¼ˆIPé¦–éƒ¨20å­—èŠ‚ï¼‰ï¼ˆé™¤éä½¿ç”¨äº†IPæŠ¥å¤´çš„å¯é€‰éƒ¨åˆ†ï¼‰ã€‚

|  Bits   |    160-167     |    168-175     |      176-183       |      184-191       |
| :-----: | :------------: | :------------: | :----------------: | :----------------: |
| **160** |      Type      |      Code      | æ ¡éªŒç ï¼ˆchecksumï¼‰ | æ ¡éªŒç ï¼ˆchecksumï¼‰ |
| **192** | Rest of Header | Rest of Header |   Rest of Header   |   Rest of Header   |

<img src="http://sm.nsddd.top/smasdasdf.png" alt="TCP/IPåè®®æ—çš„ç½‘ç»œå±‚åŸºç¡€ï¼ˆ5ï¼‰â€”â€”ICMPåè®®ä»¥åŠpingå‘½ä»¤_TLpigffçš„åšå®¢-CSDNåšå®¢" style="zoom:150%;" />



### ICMP çš„æ ¼å¼

ICMP æ¶ˆæ¯ç”±å››ä¸ªå­—æ®µç»„æˆï¼šç±»å‹ã€ä»£ç ã€æ ¡éªŒå’Œå’Œå’Œæ•°æ®ã€‚

| æ¯ä¸ªå­—æ®µ | è‹±è¯­ç¬¦å· | ä½æ•°     | æ¯ä¸ªå­—æ®µçš„è¯´æ˜                                |
| -------- | -------- | -------- | --------------------------------------------- |
| ç±»å‹     | Type     | 8 bit    | åŒ…å« ICMP æ¶ˆæ¯çš„åŠŸèƒ½ç±»å‹å€¼ã€‚ å€¼è§ä¸‹è¡¨ã€‚       |
| ä»£ç      | Code     | 8 bit    | åŒ…å« ICMP æ¶ˆæ¯çš„è¯¦ç»†åŠŸèƒ½ä»£ç çš„å€¼ã€‚ å€¼è§ä¸‹è¡¨ã€‚ |
| æ ¡éªŒå’Œ   | Checksum | 16 bit   | æ£€æŸ¥æ˜¯å¦å­˜åœ¨é”™è¯¯ã€‚                            |
| ä¸»é¢˜     | Data     | å¯å˜é•¿åº¦ | é•¿åº¦å›  ICMP çš„â€œç±»å‹â€è€Œå¼‚ã€‚                    |



## Goè¯­è¨€å®ç° Ping æ“ä½œ

::: tip æ­¥éª¤

1. ping æ“ä½œåŸç† ICMP
2. å®ç° ping æ“ä½œçš„ä¸¤ä¸ªå…³é”®ç‚¹
3. ping æ“ä½œ

:::



æˆ‘ä»¬å¸Œæœ›å¯ä»¥å‘é€ 64 å­—èŠ‚çš„æ•°æ® `-l 64`



### flag çš„ä½œç”¨

Goè¯­è¨€å†…ç½®çš„`flag`åŒ…å®ç°äº†å‘½ä»¤è¡Œå‚æ•°çš„è§£æï¼Œ`flag`åŒ…ä½¿å¾—å¼€å‘å‘½ä»¤è¡Œå·¥å…·æ›´ä¸ºç®€å•ã€‚

**å¯ä»¥ç®€å•çš„è·å–å‘½ä»¤è¡Œå‚æ•°ï¼š**

```go
package main

import (
	"fmt"
	"os"
)

//os.Args demo
func main() {
	//os.Argsæ˜¯ä¸€ä¸ª[]string
	if len(os.Args) > 0 {
		for index, arg := range os.Args {
			fmt.Printf("args[%d]=%v\n", index, arg)
		}
	}
}
```

**ğŸš€ ç¼–è¯‘ç»“æœå¦‚ä¸‹ï¼š**

```bash
PS D:\æ–‡æ¡£\æœ€è¿‘çš„\awesome-golang\docs\code\go-super> go run  .\74-main.go wefa     
args[0]=C:\Users\smile\AppData\Local\Temp\go-build1593224315\b001\exe\74-main.exe
args[1]=wefa
```

::: tip 
æ˜¯ä¸æ˜¯å¯ä»¥å’Œæˆ‘ä»¬ä¹‹å‰çš„Cobraè”åˆèµ·æ¥äº†ï¼Œæˆ–è®¸æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ Cobra å¯¹å§~

:::



### lag.Type()

åŸºæœ¬æ ¼å¼å¦‚ä¸‹ï¼š

`flag.Type(flagå, é»˜è®¤å€¼, å¸®åŠ©ä¿¡æ¯)*Type` ä¾‹å¦‚æˆ‘ä»¬è¦å®šä¹‰å§“åã€å¹´é¾„ã€å©šå¦ä¸‰ä¸ªå‘½ä»¤è¡Œå‚æ•°ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰å¦‚ä¸‹æ–¹å¼å®šä¹‰ï¼š

```go
name := flag.String("name", "å¼ ä¸‰", "å§“å")
age := flag.Int("age", 18, "å¹´é¾„")
married := flag.Bool("married", false, "å©šå¦")
delay := flag.Duration("delay", 0, "æ—¶é—´é—´éš”")
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ­¤æ—¶`name`ã€`age`ã€`married`ã€`delay`å‡ä¸ºå¯¹åº”ç±»å‹çš„æŒ‡é’ˆã€‚



### flag.TypeVar()

åŸºæœ¬æ ¼å¼å¦‚ä¸‹ï¼š `flag.TypeVar(TypeæŒ‡é’ˆ, flagå, é»˜è®¤å€¼, å¸®åŠ©ä¿¡æ¯)` ä¾‹å¦‚æˆ‘ä»¬è¦å®šä¹‰å§“åã€å¹´é¾„ã€å©šå¦ä¸‰ä¸ªå‘½ä»¤è¡Œå‚æ•°ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰å¦‚ä¸‹æ–¹å¼å®šä¹‰ï¼š

```go
var name string
var age int
var married bool
var delay time.Duration
flag.StringVar(&name, "name", "å¼ ä¸‰", "å§“å")
flag.IntVar(&age, "age", 18, "å¹´é¾„")
flag.BoolVar(&married, "married", false, "å©šå¦")
flag.DurationVar(&delay, "delay", 0, "æ—¶é—´é—´éš”")
```



### flag.Parse()

é€šè¿‡ä»¥ä¸Šä¸¤ç§æ–¹æ³•å®šä¹‰å¥½å‘½ä»¤è¡Œflagå‚æ•°åï¼Œéœ€è¦é€šè¿‡è°ƒç”¨`flag.Parse()`æ¥å¯¹å‘½ä»¤è¡Œå‚æ•°è¿›è¡Œè§£æã€‚

æ”¯æŒçš„å‘½ä»¤è¡Œå‚æ•°æ ¼å¼æœ‰ä»¥ä¸‹å‡ ç§ï¼š

+ `-flag xxx` ï¼ˆä½¿ç”¨ç©ºæ ¼ï¼Œä¸€ä¸ª`-`ç¬¦å·ï¼‰
+ `--flag xxx` ï¼ˆä½¿ç”¨ç©ºæ ¼ï¼Œä¸¤ä¸ª`-`ç¬¦å·ï¼‰
+ `-flag=xxx` ï¼ˆä½¿ç”¨ç­‰å·ï¼Œä¸€ä¸ª`-`ç¬¦å·ï¼‰
+ `--flag=xxx` ï¼ˆä½¿ç”¨ç­‰å·ï¼Œä¸¤ä¸ª`-`ç¬¦å·ï¼‰

å…¶ä¸­ï¼Œå¸ƒå°”ç±»å‹çš„å‚æ•°å¿…é¡»ä½¿ç”¨ç­‰å·çš„æ–¹å¼æŒ‡å®šã€‚

`Parse`è§£æ`os.Args[1:]`ä¸­çš„å‘½ä»¤è¡Œæ ‡å¿—ã€‚å¿…é¡»åœ¨å®šä¹‰æ‰€æœ‰æ ‡å¿—ä¹‹åå’Œåœ¨ç¨‹åºè®¿é—®æ ‡å¿—ä¹‹å‰è°ƒç”¨ã€‚



### else

```go
flag.Args()  ////è¿”å›å‘½ä»¤è¡Œå‚æ•°åçš„å…¶ä»–å‚æ•°ï¼Œä»¥[]stringç±»å‹
flag.NArg()  //è¿”å›å‘½ä»¤è¡Œå‚æ•°åçš„å…¶ä»–å‚æ•°ä¸ªæ•°
flag.NFlag() //è¿”å›ä½¿ç”¨çš„å‘½ä»¤è¡Œå‚æ•°ä¸ªæ•°
```



## è·å–å‘½ä»¤è¡Œå‚æ•°

ğŸ’¡ç®€å•çš„ä¸€ä¸ªæ¡ˆä¾‹å¦‚ä¸‹ï¼š

```go
/*
å®ç°pingæ“ä½œ
*/

package main

import (
	"flag"
	"fmt"
)

var (
	timeout int64
	size    int
	count   int
)

func main() {
	getCommandArgs()
	fmt.Println(timeout, size, count)
}

func getCommandArgs() {
	//è·å–å‘½ä»¤è¡Œå‚æ•°
	flag.Int64Var(&timeout, "t", 1000, "è¯·æ±‚è¶…æ—¶æ—¶é—´ï¼Œå•ä½æ¯«ç§’")
	flag.IntVar(&size, "s", 32, "è¯·æ±‚æ•°æ®åŒ…å¤§å°ï¼Œå•ä½å­—èŠ‚")
	flag.IntVar(&count, "c", 4, "è¯·æ±‚æ¬¡æ•°")
	flag.Parse() //è§£æå‘½ä»¤è¡Œå‚æ•°
}
```

ğŸš€ ç¼–è¯‘ç»“æœå¦‚ä¸‹ï¼š

```bash
PS D:\go-super> go run  .\73-main.go               
1000 32 4
PS D:\go-super> go run  .\73-main.go -t 1234 -s 128 -c 6
1234 128 6
```



## è·å–è¯·æ±‚

**æ³¨æ„å¤§å°ç«¯åŒºåˆ«ï¼š**

```go
/*
å®ç°pingæ“ä½œ
*/

package main

import (
	"bytes"
	"encoding/binary"
	"flag"
	"fmt"
	"net"
	"os"
	"time"
)

type ICMP struct {
	Type     uint8  //æ¶ˆæ¯ç±»å‹
	Code     uint8  //ç±»å‹å­ç 
	Checksum uint16 //æ ¡éªŒå’Œ
	//æ ‡è¯†ç¬¦å’Œåºåˆ—å·
	ID  uint16 //æ ‡è¯†ç¬¦
	Seq uint16 //åºåˆ—å·
}

var (
	timeout int64
	size    int
	count   int
	icmp    *ICMP = &ICMP{
		Type:     8,
		Code:     0,
		Checksum: 3,
		ID:       6,
		Seq:      0,
	}
)

func main() {
	getCommandArgs()

	//ç›®æ ‡ipåœ°å€
	desIp := os.Args[len(os.Args)-1] //è·å–æœ€åä¸€ä¸ªå‚æ•°

	//æ„å»ºè¯·æ±‚
	conn, err := net.DialTimeout("ip4:icmp", desIp, time.Duration(timeout)*time.Millisecond)
	if err != nil {
		fmt.Println("è¯·æ±‚å¤±è´¥")
		return
	}
	defer conn.Close()
	data := make([]byte, size)
	fmt.Println("æ­£åœ¨ Ping", desIp, " å…·æœ‰ 32 å­—èŠ‚çš„æ•°æ®:", "data:", data)

	var buffer bytes.Buffer
	fmt.Printf("å¤§ç«¯ï¼š")
	binary.Write(&buffer, binary.BigEndian, &icmp) //å†™å…¥ç±»å‹
	fmt.Println("icmp:", icmp)

	var buffer2 bytes.Buffer
	fmt.Printf("å°ç«¯ï¼š")
	binary.Write(&buffer2, binary.LittleEndian, &icmp) //å†™å…¥ç±»å‹
	/*
		binary.BigEndian: å¤§ç«¯åº
		binary.LittleEndian: å°ç«¯åº
	*/
	fmt.Println("icmp:", icmp)

	for i := 0; i < count; i++ {
		_, err := conn.Write(data)
		if err != nil {
			fmt.Println("å‘é€å¤±è´¥")
			return
		}
		//è®¾ç½®è¶…æ—¶æ—¶é—´
		conn.SetReadDeadline(time.Now().Add(time.Duration(timeout) * time.Millisecond))
		_, err = conn.Read(data)
		if err != nil {
			fmt.Println("æ¥æ”¶å¤±è´¥")
			return
		}
		fmt.Println("æ¥æ”¶æˆåŠŸ")
	}
}

func getCommandArgs() {
	//è·å–å‘½ä»¤è¡Œå‚æ•°
	flag.Int64Var(&timeout, "t", 1000, "è¯·æ±‚è¶…æ—¶æ—¶é—´ï¼Œå•ä½æ¯«ç§’")
	flag.IntVar(&size, "s", 32, "è¯·æ±‚æ•°æ®åŒ…å¤§å°ï¼Œå•ä½å­—èŠ‚")
	flag.IntVar(&count, "c", 4, "è¯·æ±‚æ¬¡æ•°")
	flag.Parse() //è§£æå‘½ä»¤è¡Œå‚æ•°
}

```

ğŸš€ ç¼–è¯‘ç»“æœå¦‚ä¸‹ï¼š

```
$ go run  73-main.go -t 128 -s 36 -c 6 www.baidu.com
æ­£åœ¨ Ping www.baidu.com  å…·æœ‰ 32 å­—èŠ‚çš„æ•°æ®: data: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
å¤§ç«¯ï¼šicmp: &{8 0 0 1 1}
å°ç«¯ï¼šicmp: &{8 0 0 1 1}
å‘é€å¤±è´¥
```



**æ ¡éªŒï¼š**

```go
func Checksum(data []byte) uint16 { //å®šä¹‰æ ¡éªŒå’Œå‡½æ•°ï¼šå‚æ•°ä¸ºå­—èŠ‚åˆ‡ç‰‡ï¼Œè¿”å›å€¼ä¸ºuint16
	var sum uint32
	for i := 0; i < len(data); i += 2 { //æ¯æ¬¡å–ä¸¤ä¸ªå­—èŠ‚
		sum += uint32(data[i])<<8 + uint32(data[i+1]) //å°†æ¯ä¸¤ä¸ªå­—èŠ‚è½¬æ¢ä¸ºuint16ç±»å‹ï¼Œç„¶åç›¸åŠ 
	}
	sum = (sum >> 16) + (sum & 0xffff) //é«˜16ä½ä¸ä½16ä½ç›¸åŠ 
	sum += sum >> 16                   //å°†è¿›ä½çš„1åŠ åˆ°ä½16ä½
	return uint16(^sum)                //å–å
}
```



## æ¡ˆä¾‹

ğŸ’¡ç®€å•çš„ä¸€ä¸ªæ¡ˆä¾‹å¦‚ä¸‹ï¼š

```go
package main

import (
	"bytes"
	"encoding/binary"
	"flag"
	"fmt"
	"log"
	"math"
	"net"
	"os"
	"time"
)

type ICMP struct {
	Type        uint8
	Code        uint8
	Checksum    uint16
	Identifier  uint16
	SequenceNum uint16
}

var (
	icmp    ICMP
	laddr   = net.IPAddr{IP: net.ParseIP("ip")}
	num     int
	timeout int64
	size    int
	stop    bool
)

func main() {
	ParseArgs()
	args := os.Args

	if len(args) < 2 { // æ²¡æœ‰è¾“å…¥ä¸»æœºåœ°å€
		Usage()
	}
	desIp := args[len(args)-1]

	conn, err := net.DialTimeout("ip:icmp", desIp, time.Duration(timeout)*time.Millisecond)
	if err != nil {
		log.Fatal(err)
	}

	defer conn.Close()
	//icmpå¤´éƒ¨å¡«å……
	icmp.Type = 8
	icmp.Code = 0
	icmp.Checksum = 0
	icmp.Identifier = 1
	icmp.SequenceNum = 1

	fmt.Printf("\næ­£åœ¨ ping %s å…·æœ‰ %d å­—èŠ‚çš„æ•°æ®:\n", desIp, size)

	var buffer bytes.Buffer
	binary.Write(&buffer, binary.BigEndian, icmp) // ä»¥å¤§ç«¯æ¨¡å¼å†™å…¥
	data := make([]byte, size)                    //
	buffer.Write(data)
	data = buffer.Bytes()

	var SuccessTimes int // æˆåŠŸæ¬¡æ•°
	var FailTimes int    // å¤±è´¥æ¬¡æ•°
	var minTime int = int(math.MaxInt32)
	var maxTime int
	var totalTime int
	for i := 0; i < num; i++ {
		icmp.SequenceNum = uint16(1)
		// æ£€éªŒå’Œè®¾ä¸º0
		data[2] = byte(0)
		data[3] = byte(0)

		data[6] = byte(icmp.SequenceNum >> 8)
		data[7] = byte(icmp.SequenceNum)
		icmp.Checksum = CheckSum(data)
		data[2] = byte(icmp.Checksum >> 8)
		data[3] = byte(icmp.Checksum)

		// å¼€å§‹æ—¶é—´
		t1 := time.Now()
		conn.SetDeadline(t1.Add(time.Duration(time.Duration(timeout) * time.Millisecond)))
		n, err := conn.Write(data)
		if err != nil {
			log.Fatal(err)
		}
		buf := make([]byte, 65535)
		n, err = conn.Read(buf)
		if err != nil {
			fmt.Println("è¯·æ±‚è¶…æ—¶ã€‚")
			FailTimes++
			continue
		}
		et := int(time.Since(t1) / 1000000)
		if minTime > et {
			minTime = et
		}
		if maxTime < et {
			maxTime = et
		}
		totalTime += et
		fmt.Printf("æ¥è‡ª %s çš„å›å¤: å­—èŠ‚=%d æ—¶é—´=%dms TTL=%d\n", desIp, len(buf[28:n]), et, buf[8])
		SuccessTimes++
		time.Sleep(1 * time.Second)
	}
	fmt.Printf("\n%s çš„ Ping ç»Ÿè®¡ä¿¡æ¯:\n", desIp)
	fmt.Printf("    æ•°æ®åŒ…: å·²å‘é€ = %dï¼Œå·²æ¥æ”¶ = %dï¼Œä¸¢å¤± = %d (%.2f%% ä¸¢å¤±)ï¼Œ\n", SuccessTimes+FailTimes, SuccessTimes, FailTimes, float64(FailTimes*100)/float64(SuccessTimes+FailTimes))
	if maxTime != 0 && minTime != int(math.MaxInt32) {
		fmt.Printf("å¾€è¿”è¡Œç¨‹çš„ä¼°è®¡æ—¶é—´(ä»¥æ¯«ç§’ä¸ºå•ä½):\n")
		fmt.Printf("    æœ€çŸ­ = %dmsï¼Œæœ€é•¿ = %dmsï¼Œå¹³å‡ = %dms\n", minTime, maxTime, totalTime/SuccessTimes)
	}
}

func CheckSum(data []byte) uint16 {
	var sum uint32
	var length = len(data)
	var index int
	for length > 1 { // æº¢å‡ºéƒ¨åˆ†ç›´æ¥å»é™¤
		sum += uint32(data[index])<<8 + uint32(data[index+1])
		index += 2
		length -= 2
	}
	if length == 1 {
		sum += uint32(data[index])
	}
	// CheckSumçš„å€¼æ˜¯16ä½ï¼Œè®¡ç®—æ˜¯å°†é«˜16ä½åŠ ä½16ä½ï¼Œå¾—åˆ°çš„ç»“æœè¿›è¡Œé‡å¤ä»¥è¯¥æ–¹å¼è¿›è¡Œè®¡ç®—ï¼Œç›´åˆ°é«˜16ä½ä¸º0
	/*
	   sumçš„æœ€å¤§æƒ…å†µæ˜¯ï¼šffffffff
	   ç¬¬ä¸€æ¬¡é«˜16ä½+ä½16ä½ï¼šffff + ffff = 1fffe
	   ç¬¬äºŒæ¬¡é«˜16ä½+ä½16ä½ï¼š0001 + fffe = ffff
	   å³æ¨å‡ºä¸€ä¸ªç»“è®ºï¼Œåªè¦ç¬¬ä¸€æ¬¡é«˜16ä½+ä½16ä½çš„ç»“æœï¼Œå†è¿›è¡Œä¹‹å‰çš„è®¡ç®—ç»“æœç”¨åˆ°é«˜16ä½+ä½16ä½ï¼Œå³å¯å¤„ç†æº¢å‡ºæƒ…å†µ
	*/
	sum = uint32(sum>>16) + uint32(sum)
	sum = uint32(sum>>16) + uint32(sum)
	return uint16(^sum)
}

func ParseArgs() {
	flag.Int64Var(&timeout, "w", 1500, "ç­‰å¾…æ¯æ¬¡å›å¤çš„è¶…æ—¶æ—¶é—´(æ¯«ç§’)")
	flag.IntVar(&num, "n", 4, "è¦å‘é€çš„è¯·æ±‚æ•°")
	flag.IntVar(&size, "l", 32, "è¦å‘é€ç¼“å†²åŒºå¤§å°")
	flag.BoolVar(&stop, "t", false, "Ping æŒ‡å®šçš„ä¸»æœºï¼Œç›´åˆ°åœæ­¢")

	flag.Parse()
}

func Usage() {
	argNum := len(os.Args)
	if argNum < 2 {
		fmt.Print(
			`
ç”¨æ³•: ping [-t] [-a] [-n count] [-l size] [-f] [-i TTL] [-v TOS]
            [-r count] [-s count] [[-j host-list] | [-k host-list]]
            [-w timeout] [-R] [-S srcaddr] [-c compartment] [-p]
            [-4] [-6] target_name
é€‰é¡¹:
    -t             Ping æŒ‡å®šçš„ä¸»æœºï¼Œç›´åˆ°åœæ­¢ã€‚
                   è‹¥è¦æŸ¥çœ‹ç»Ÿè®¡ä¿¡æ¯å¹¶ç»§ç»­æ“ä½œï¼Œè¯·é”®å…¥ Ctrl+Breakï¼›
                   è‹¥è¦åœæ­¢ï¼Œè¯·é”®å…¥ Ctrl+Cã€‚
    -a             å°†åœ°å€è§£æä¸ºä¸»æœºåã€‚
    -n count       è¦å‘é€çš„å›æ˜¾è¯·æ±‚æ•°ã€‚
    -l size        å‘é€ç¼“å†²åŒºå¤§å°ã€‚
    -f             åœ¨æ•°æ®åŒ…ä¸­è®¾ç½®â€œä¸åˆ†æ®µâ€æ ‡è®°(ä»…é€‚ç”¨äº IPv4)ã€‚
    -i TTL         ç”Ÿå­˜æ—¶é—´ã€‚
    -v TOS         æœåŠ¡ç±»å‹(ä»…é€‚ç”¨äº IPv4ã€‚è¯¥è®¾ç½®å·²è¢«å¼ƒç”¨ï¼Œ
                   å¯¹ IP æ ‡å¤´ä¸­çš„æœåŠ¡ç±»å‹å­—æ®µæ²¡æœ‰ä»»ä½•
                   å½±å“)ã€‚
    -r count       è®°å½•è®¡æ•°è·ƒç‚¹çš„è·¯ç”±(ä»…é€‚ç”¨äº IPv4)ã€‚
    -s count       è®¡æ•°è·ƒç‚¹çš„æ—¶é—´æˆ³(ä»…é€‚ç”¨äº IPv4)ã€‚
    -j host-list   ä¸ä¸»æœºåˆ—è¡¨ä¸€èµ·ä½¿ç”¨çš„æ¾æ•£æºè·¯ç”±(ä»…é€‚ç”¨äº IPv4)ã€‚
    -k host-list    ä¸ä¸»æœºåˆ—è¡¨ä¸€èµ·ä½¿ç”¨çš„ä¸¥æ ¼æºè·¯ç”±(ä»…é€‚ç”¨äº IPv4)ã€‚
    -w timeout     ç­‰å¾…æ¯æ¬¡å›å¤çš„è¶…æ—¶æ—¶é—´(æ¯«ç§’)ã€‚
    -R             åŒæ ·ä½¿ç”¨è·¯ç”±æ ‡å¤´æµ‹è¯•åå‘è·¯ç”±(ä»…é€‚ç”¨äº IPv6)ã€‚
                   æ ¹æ® RFC 5095ï¼Œå·²å¼ƒç”¨æ­¤è·¯ç”±æ ‡å¤´ã€‚
                   å¦‚æœä½¿ç”¨æ­¤æ ‡å¤´ï¼ŒæŸäº›ç³»ç»Ÿå¯èƒ½ä¸¢å¼ƒ
                   å›æ˜¾è¯·æ±‚ã€‚
    -S srcaddr     è¦ä½¿ç”¨çš„æºåœ°å€ã€‚
    -c compartment è·¯ç”±éš”ç¦»èˆ±æ ‡è¯†ç¬¦ã€‚
    -p             Ping Hyper-V ç½‘ç»œè™šæ‹ŸåŒ–æä¾›ç¨‹åºåœ°å€ã€‚
    -4             å¼ºåˆ¶ä½¿ç”¨ IPv4ã€‚
    -6             å¼ºåˆ¶ä½¿ç”¨ IPv6ã€‚
`)
	}
}

```

ğŸš€ ç¼–è¯‘ç»“æœå¦‚ä¸‹ï¼š

```bash
$ go run  76-main.go -t 128 -s 36 -c 6 www.baidu.com     
æ­£åœ¨ ping www.baidu.com å…·æœ‰ 32 å­—èŠ‚çš„æ•°æ®:
æ¥è‡ª www.baidu.com çš„å›å¤: å­—èŠ‚=32 æ—¶é—´=25ms TTL=55
æ¥è‡ª www.baidu.com çš„å›å¤: å­—èŠ‚=32 æ—¶é—´=26ms TTL=55
æ¥è‡ª www.baidu.com çš„å›å¤: å­—èŠ‚=32 æ—¶é—´=21ms TTL=55

www.baidu.com çš„ Ping ç»Ÿè®¡ä¿¡æ¯:
    æ•°æ®åŒ…: å·²å‘é€ = 4ï¼Œå·²æ¥æ”¶ = 4ï¼Œä¸¢å¤± = 0 (0.00% ä¸¢å¤±)ï¼Œ
å¾€è¿”è¡Œç¨‹çš„ä¼°è®¡æ—¶é—´(ä»¥æ¯«ç§’ä¸ºå•ä½):
    æœ€çŸ­ = 21msï¼Œæœ€é•¿ = 29msï¼Œå¹³å‡ = 25ms
```



## END é“¾æ¥

+ [å›åˆ°ç›®å½•](../README.md)
+ [ä¸Šä¸€èŠ‚](18.md)
+ [ä¸‹ä¸€èŠ‚](20.md)
---
+ [å‚ä¸è´¡çŒ®â¤ï¸ğŸ’•ğŸ’•](https://github.com/3293172751/Block_Chain/blob/master/Git/git-contributor.md)