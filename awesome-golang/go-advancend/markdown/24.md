+ [author](https://github.com/3293172751)

# ç¬¬24èŠ‚ SOCKS5 ä»£ç†ï¼ˆè°ƒç”¨ç¬¬ä¸‰æ–¹APIæ¡ˆä¾‹ï¼‰

+ [å›åˆ°ç›®å½•](../README.md)
+ [ä¸Šä¸€èŠ‚](23.md)
> â¤ï¸ğŸ’•ğŸ’•Goè¯­è¨€é«˜çº§ç¯‡ç« ,åœ¨æ­¤ä¹‹å‰å»ºè®®æ‚¨å…ˆäº†è§£åŸºç¡€å’Œè¿›é˜¶ç¯‡ã€‚Myblog:[http://nsddd.top](http://nsddd.top/)
###  **[Goè¯­è¨€åŸºç¡€ç¯‡](https://github.com/cubxxw/awesome-cs-cloudnative-blockchain/blob/master/TOC.md)**
###  **[Goè¯­è¨€100ç¯‡è¿›é˜¶](https://github.com/cubxxw/awesome-cs-cloudnative-blockchain/blob/master/Gomd_super/README.md)**
---
[TOC]

## Clashä»‹ç»

+ [clash é¡¹ç›®åœ°å€](https://github.com/Dreamacro/clash)

**ç‰¹ç‚¹ï¼š**

+ æ”¯æŒèº«ä»½éªŒè¯çš„æœ¬åœ°HTTP/HTTPS/SOCKSæœåŠ¡å™¨
+ Shadowsocksï¼ˆRï¼‰ã€VMessã€ç‰¹æ´›ä¼Šæœ¨é©¬ã€Snellã€SOCKS5ã€HTTPï¼ˆSï¼‰å‡ºç«™æ”¯æŒ
+ å†…ç½® [ä¼ªip](https://www.rfc-editor.org/rfc/rfc3089)DNSæœåŠ¡å™¨ï¼Œæ—¨åœ¨æœ€å¤§é™åº¦åœ°å‡å°‘DNSæ±¡æŸ“æ”»å‡»çš„å½±å“ã€‚æ”¯æŒDoH/DoTä¸Šæ¸¸ã€‚
+ åŸºäºåŸŸã€GEOIPã€IP-CIDRæˆ–è¿›ç¨‹åç§°çš„è§„åˆ™å°†æ•°æ®åŒ…è·¯ç”±åˆ°ä¸åŒçš„ç›®çš„åœ°
+ ä»£ç†ç»„å…è®¸ç”¨æˆ·å®æ–½å¼ºå¤§çš„è§„åˆ™ã€‚æ”¯æŒè‡ªåŠ¨å›é€€ã€è´Ÿè½½å¹³è¡¡æˆ–åŸºäºå»¶è¿Ÿè‡ªåŠ¨é€‰æ‹©ä»£ç†
+ è¿œç¨‹æä¾›ç¨‹åºï¼Œå…è®¸ç”¨æˆ·è¿œç¨‹è·å–ä»£ç†åˆ—è¡¨ï¼Œè€Œä¸æ˜¯åœ¨é…ç½®ä¸­ç¡¬ç¼–ç 
+ é€æ˜ä»£ç†ï¼šä½¿ç”¨è‡ªåŠ¨è·¯ç”±è¡¨/è§„åˆ™ç®¡ç†é‡å®šå‘TCPå’ŒTProxy TCP/UDP
+ é€šè¿‡å…¨é¢çš„HTTP RESTful APIæ§åˆ¶å™¨è¿›è¡Œçƒ­é‡æ–°åŠ è½½



## åŸç†ä»‹ç»

SOCKS5æ˜¯ç”¨äºé€šè¿‡ä»£ç†æœåŠ¡å™¨å®‰å…¨åœ°è·¯ç”±ç½‘ç»œæµé‡çš„åè®®ã€‚å®ƒé€šå¸¸ç”¨äºç»•è¿‡ç½‘ç»œé™åˆ¶å’Œè®¿é—®è¢«é˜»æ­¢çš„ç½‘ç«™ã€‚SOCKS5ä¸ºSOCKSåè®®æ·»åŠ äº†é¢å¤–çš„åŠŸèƒ½ï¼Œä¾‹å¦‚éªŒè¯ç”¨æˆ·èº«ä»½çš„èƒ½åŠ›ä»¥åŠå¯¹TCPå’ŒUDPæµé‡çš„æ”¯æŒã€‚SOCKS5ä»£ç†æœåŠ¡å™¨å……å½“å®¢æˆ·ç«¯å’Œç›®æ ‡æœåŠ¡å™¨ä¹‹é—´çš„ä¸­é—´äººï¼Œåœ¨å®ƒä»¬ä¹‹é—´è½¬å‘æµé‡ï¼ŒåŒæ—¶éšè—å®¢æˆ·ç«¯çš„IPåœ°å€ã€‚è¿™å…è®¸å®¢æˆ·ç«¯è®¿é—®ç›®æ ‡æœåŠ¡å™¨ä¸Šçš„èµ„æºï¼Œå°±å¥½åƒå®ƒä»¬ä½äºåŒä¸€ç½‘ç»œä¸Šä¸€æ ·ã€‚

![image-20230114164536220](http://sm.nsddd.top/sm202301141645441.png)



## ç¬¬ä¸€æ­¥ï¼Œä¸€ä¸ªç®€å•çš„é“¾æ¥

```go
package main

import (
	"bufio"
	"log"
	"net"
)

func main() {
	server, err := net.Listen("tcp", "127.0.0.1:1080")
	if err != nil {
		panic(err)
	}
	for {
		client, err := server.Accept()
		if err != nil {
			log.Printf("Accept failed %v", err)
			continue
		}
		go process(client)
	}
}

func process(conn net.Conn) {
	defer conn.Close()
	reader := bufio.NewReader(conn)
	for {
		b, err := reader.ReadByte()
		if err != nil {
			break
		}
		_, err = conn.Write([]byte{b})
		if err != nil {
			break
		}
	}
}

```

**æµ‹è¯•ï¼š**

```
go run main.go
nc 127.0.0.1 1080
```



## è®¤è¯é˜¶æ®µ

ä»£ç ï¼š

```go
package main

import (
	"bufio"
	"fmt"
	"io"
	"log"
	"net"
)

const socks5Ver = 0x05
const cmdBind = 0x01
const atypIPV4 = 0x01
const atypeHOST = 0x03
const atypeIPV6 = 0x04

func main() {
	server, err := net.Listen("tcp", "127.0.0.1:1080")
	if err != nil {
		panic(err)
	}
	for {
		client, err := server.Accept()
		if err != nil {
			log.Printf("Accept failed %v", err)
			continue
		}
		go process(client)
	}
}

func process(conn net.Conn) {
	defer conn.Close()
	reader := bufio.NewReader(conn)
	err := auth(reader, conn)
	if err != nil {
		log.Printf("client %v auth failed:%v", conn.RemoteAddr(), err)
		return
	}
	log.Println("auth success")
}

func auth(reader *bufio.Reader, conn net.Conn) (err error) {
	// +----+----------+----------+
	// |VER | NMETHODS | METHODS  |
	// +----+----------+----------+
	// | 1  |    1     | 1 to 255 |
	// +----+----------+----------+
	// VER: åè®®ç‰ˆæœ¬ï¼Œsocks5ä¸º0x05
	// NMETHODS: æ”¯æŒè®¤è¯çš„æ–¹æ³•æ•°é‡
	// METHODS: å¯¹åº”NMETHODSï¼ŒNMETHODSçš„å€¼ä¸ºå¤šå°‘ï¼ŒMETHODSå°±æœ‰å¤šå°‘ä¸ªå­—èŠ‚ã€‚RFCé¢„å®šä¹‰äº†ä¸€äº›å€¼çš„å«ä¹‰ï¼Œå†…å®¹å¦‚ä¸‹:
	// Xâ€™00â€™ NO AUTHENTICATION REQUIRED
	// Xâ€™02â€™ USERNAME/PASSWORD

	ver, err := reader.ReadByte()
	if err != nil {
		return fmt.Errorf("read ver failed:%w", err)
	}
	if ver != socks5Ver {
		return fmt.Errorf("not supported ver:%v", ver)
	}
	methodSize, err := reader.ReadByte()
	if err != nil {
		return fmt.Errorf("read methodSize failed:%w", err)
	}
	method := make([]byte, methodSize)
	_, err = io.ReadFull(reader, method)
	if err != nil {
		return fmt.Errorf("read method failed:%w", err)
	}
	log.Println("ver", ver, "method", method)
	// +----+--------+
	// |VER | METHOD |
	// +----+--------+
	// | 1  |   1    |
	// +----+--------+
	_, err = conn.Write([]byte{socks5Ver, 0x00})
	if err != nil {
		return fmt.Errorf("write failed:%w", err)
	}
	return nil
}

```



## è¯·æ±‚é˜¶æ®µ

```go
package main

import (
	"bufio"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"log"
	"net"
)

const socks5Ver = 0x05
const cmdBind = 0x01
const atypIPV4 = 0x01
const atypeHOST = 0x03
const atypeIPV6 = 0x04

func main() {
	server, err := net.Listen("tcp", "127.0.0.1:1080")
	if err != nil {
		panic(err)
	}
	for {
		client, err := server.Accept()
		if err != nil {
			log.Printf("Accept failed %v", err)
			continue
		}
		go process(client)
	}
}

func process(conn net.Conn) {
	defer conn.Close()
	reader := bufio.NewReader(conn)
	err := auth(reader, conn)
	if err != nil {
		log.Printf("client %v auth failed:%v", conn.RemoteAddr(), err)
		return
	}
	err = connect(reader, conn)
	if err != nil {
		log.Printf("client %v auth failed:%v", conn.RemoteAddr(), err)
		return
	}
}

func auth(reader *bufio.Reader, conn net.Conn) (err error) {
	// +----+----------+----------+
	// |VER | NMETHODS | METHODS  |
	// +----+----------+----------+
	// | 1  |    1     | 1 to 255 |
	// +----+----------+----------+
	// VER: åè®®ç‰ˆæœ¬ï¼Œsocks5ä¸º0x05
	// NMETHODS: æ”¯æŒè®¤è¯çš„æ–¹æ³•æ•°é‡
	// METHODS: å¯¹åº”NMETHODSï¼ŒNMETHODSçš„å€¼ä¸ºå¤šå°‘ï¼ŒMETHODSå°±æœ‰å¤šå°‘ä¸ªå­—èŠ‚ã€‚RFCé¢„å®šä¹‰äº†ä¸€äº›å€¼çš„å«ä¹‰ï¼Œå†…å®¹å¦‚ä¸‹:
	// Xâ€™00â€™ NO AUTHENTICATION REQUIRED
	// Xâ€™02â€™ USERNAME/PASSWORD

	ver, err := reader.ReadByte()
	if err != nil {
		return fmt.Errorf("read ver failed:%w", err)
	}
	if ver != socks5Ver {
		return fmt.Errorf("not supported ver:%v", ver)
	}
	methodSize, err := reader.ReadByte()
	if err != nil {
		return fmt.Errorf("read methodSize failed:%w", err)
	}
	method := make([]byte, methodSize)
	_, err = io.ReadFull(reader, method)
	if err != nil {
		return fmt.Errorf("read method failed:%w", err)
	}

	// +----+--------+
	// |VER | METHOD |
	// +----+--------+
	// | 1  |   1    |
	// +----+--------+
	_, err = conn.Write([]byte{socks5Ver, 0x00})
	if err != nil {
		return fmt.Errorf("write failed:%w", err)
	}
	return nil
}

func connect(reader *bufio.Reader, conn net.Conn) (err error) {
	// +----+-----+-------+------+----------+----------+
	// |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
	// +----+-----+-------+------+----------+----------+
	// | 1  |  1  | X'00' |  1   | Variable |    2     |
	// +----+-----+-------+------+----------+----------+
	// VER ç‰ˆæœ¬å·ï¼Œsocks5çš„å€¼ä¸º0x05
	// CMD 0x01è¡¨ç¤ºCONNECTè¯·æ±‚
	// RSV ä¿ç•™å­—æ®µï¼Œå€¼ä¸º0x00
	// ATYP ç›®æ ‡åœ°å€ç±»å‹ï¼ŒDST.ADDRçš„æ•°æ®å¯¹åº”è¿™ä¸ªå­—æ®µçš„ç±»å‹ã€‚
	//   0x01è¡¨ç¤ºIPv4åœ°å€ï¼ŒDST.ADDRä¸º4ä¸ªå­—èŠ‚
	//   0x03è¡¨ç¤ºåŸŸåï¼ŒDST.ADDRæ˜¯ä¸€ä¸ªå¯å˜é•¿åº¦çš„åŸŸå
	// DST.ADDR ä¸€ä¸ªå¯å˜é•¿åº¦çš„å€¼
	// DST.PORT ç›®æ ‡ç«¯å£ï¼Œå›ºå®š2ä¸ªå­—èŠ‚

	buf := make([]byte, 4)
	_, err = io.ReadFull(reader, buf)
	if err != nil {
		return fmt.Errorf("read header failed:%w", err)
	}
	ver, cmd, atyp := buf[0], buf[1], buf[3]
	if ver != socks5Ver {
		return fmt.Errorf("not supported ver:%v", ver)
	}
	if cmd != cmdBind {
		return fmt.Errorf("not supported cmd:%v", ver)
	}
	addr := ""
	switch atyp {
	case atypIPV4:
		_, err = io.ReadFull(reader, buf)
		if err != nil {
			return fmt.Errorf("read atyp failed:%w", err)
		}
		addr = fmt.Sprintf("%d.%d.%d.%d", buf[0], buf[1], buf[2], buf[3])
	case atypeHOST:
		hostSize, err := reader.ReadByte()
		if err != nil {
			return fmt.Errorf("read hostSize failed:%w", err)
		}
		host := make([]byte, hostSize)
		_, err = io.ReadFull(reader, host)
		if err != nil {
			return fmt.Errorf("read host failed:%w", err)
		}
		addr = string(host)
	case atypeIPV6:
		return errors.New("IPv6: no supported yet")
	default:
		return errors.New("invalid atyp")
	}
	_, err = io.ReadFull(reader, buf[:2])
	if err != nil {
		return fmt.Errorf("read port failed:%w", err)
	}
	port := binary.BigEndian.Uint16(buf[:2])

	log.Println("dial", addr, port)

	// +----+-----+-------+------+----------+----------+
	// |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
	// +----+-----+-------+------+----------+----------+
	// | 1  |  1  | X'00' |  1   | Variable |    2     |
	// +----+-----+-------+------+----------+----------+
	// VER socksç‰ˆæœ¬ï¼Œè¿™é‡Œä¸º0x05
	// REP Relay field,å†…å®¹å–å€¼å¦‚ä¸‹ Xâ€™00â€™ succeeded
	// RSV ä¿ç•™å­—æ®µ
	// ATYPE åœ°å€ç±»å‹
	// BND.ADDR æœåŠ¡ç»‘å®šçš„åœ°å€
	// BND.PORT æœåŠ¡ç»‘å®šçš„ç«¯å£DST.PORT
	_, err = conn.Write([]byte{0x05, 0x00, 0x00, 0x01, 0, 0, 0, 0, 0, 0})
	if err != nil {
		return fmt.Errorf("write failed: %w", err)
	}
	return nil
}

```



## relay é˜¶æ®µ

```go
package main

import (
	"bufio"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"log"
	"net"
)

const socks5Ver = 0x05
const cmdBind = 0x01
const atypIPV4 = 0x01
const atypeHOST = 0x03
const atypeIPV6 = 0x04

func main() {
	server, err := net.Listen("tcp", "127.0.0.1:1080")
	if err != nil {
		panic(err)
	}
	for {
		client, err := server.Accept()
		if err != nil {
			log.Printf("Accept failed %v", err)
			continue
		}
		go process(client)
	}
}

func process(conn net.Conn) {
	defer conn.Close()
	reader := bufio.NewReader(conn)
	err := auth(reader, conn)
	if err != nil {
		log.Printf("client %v auth failed:%v", conn.RemoteAddr(), err)
		return
	}
	err = connect(reader, conn)
	if err != nil {
		log.Printf("client %v auth failed:%v", conn.RemoteAddr(), err)
		return
	}
}

func auth(reader *bufio.Reader, conn net.Conn) (err error) {
	// +----+----------+----------+
	// |VER | NMETHODS | METHODS  |
	// +----+----------+----------+
	// | 1  |    1     | 1 to 255 |
	// +----+----------+----------+
	// VER: åè®®ç‰ˆæœ¬ï¼Œsocks5ä¸º0x05
	// NMETHODS: æ”¯æŒè®¤è¯çš„æ–¹æ³•æ•°é‡
	// METHODS: å¯¹åº”NMETHODSï¼ŒNMETHODSçš„å€¼ä¸ºå¤šå°‘ï¼ŒMETHODSå°±æœ‰å¤šå°‘ä¸ªå­—èŠ‚ã€‚RFCé¢„å®šä¹‰äº†ä¸€äº›å€¼çš„å«ä¹‰ï¼Œå†…å®¹å¦‚ä¸‹:
	// Xâ€™00â€™ NO AUTHENTICATION REQUIRED
	// Xâ€™02â€™ USERNAME/PASSWORD

	ver, err := reader.ReadByte()
	if err != nil {
		return fmt.Errorf("read ver failed:%w", err)
	}
	if ver != socks5Ver {
		return fmt.Errorf("not supported ver:%v", ver)
	}
	methodSize, err := reader.ReadByte()
	if err != nil {
		return fmt.Errorf("read methodSize failed:%w", err)
	}
	method := make([]byte, methodSize)
	_, err = io.ReadFull(reader, method)
	if err != nil {
		return fmt.Errorf("read method failed:%w", err)
	}

	// +----+--------+
	// |VER | METHOD |
	// +----+--------+
	// | 1  |   1    |
	// +----+--------+
	_, err = conn.Write([]byte{socks5Ver, 0x00})
	if err != nil {
		return fmt.Errorf("write failed:%w", err)
	}
	return nil
}

func connect(reader *bufio.Reader, conn net.Conn) (err error) {
	// +----+-----+-------+------+----------+----------+
	// |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
	// +----+-----+-------+------+----------+----------+
	// | 1  |  1  | X'00' |  1   | Variable |    2     |
	// +----+-----+-------+------+----------+----------+
	// VER ç‰ˆæœ¬å·ï¼Œsocks5çš„å€¼ä¸º0x05
	// CMD 0x01è¡¨ç¤ºCONNECTè¯·æ±‚
	// RSV ä¿ç•™å­—æ®µï¼Œå€¼ä¸º0x00
	// ATYP ç›®æ ‡åœ°å€ç±»å‹ï¼ŒDST.ADDRçš„æ•°æ®å¯¹åº”è¿™ä¸ªå­—æ®µçš„ç±»å‹ã€‚
	//   0x01è¡¨ç¤ºIPv4åœ°å€ï¼ŒDST.ADDRä¸º4ä¸ªå­—èŠ‚
	//   0x03è¡¨ç¤ºåŸŸåï¼ŒDST.ADDRæ˜¯ä¸€ä¸ªå¯å˜é•¿åº¦çš„åŸŸå
	// DST.ADDR ä¸€ä¸ªå¯å˜é•¿åº¦çš„å€¼
	// DST.PORT ç›®æ ‡ç«¯å£ï¼Œå›ºå®š2ä¸ªå­—èŠ‚

	buf := make([]byte, 4)
	_, err = io.ReadFull(reader, buf)
	if err != nil {
		return fmt.Errorf("read header failed:%w", err)
	}
	ver, cmd, atyp := buf[0], buf[1], buf[3]
	if ver != socks5Ver {
		return fmt.Errorf("not supported ver:%v", ver)
	}
	if cmd != cmdBind {
		return fmt.Errorf("not supported cmd:%v", ver)
	}
	addr := ""
	switch atyp {
	case atypIPV4:
		_, err = io.ReadFull(reader, buf)
		if err != nil {
			return fmt.Errorf("read atyp failed:%w", err)
		}
		addr = fmt.Sprintf("%d.%d.%d.%d", buf[0], buf[1], buf[2], buf[3])
	case atypeHOST:
		hostSize, err := reader.ReadByte()
		if err != nil {
			return fmt.Errorf("read hostSize failed:%w", err)
		}
		host := make([]byte, hostSize)
		_, err = io.ReadFull(reader, host)
		if err != nil {
			return fmt.Errorf("read host failed:%w", err)
		}
		addr = string(host)
	case atypeIPV6:
		return errors.New("IPv6: no supported yet")
	default:
		return errors.New("invalid atyp")
	}
	_, err = io.ReadFull(reader, buf[:2])
	if err != nil {
		return fmt.Errorf("read port failed:%w", err)
	}
	port := binary.BigEndian.Uint16(buf[:2])

	log.Println("dial", addr, port)

	// +----+-----+-------+------+----------+----------+
	// |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
	// +----+-----+-------+------+----------+----------+
	// | 1  |  1  | X'00' |  1   | Variable |    2     |
	// +----+-----+-------+------+----------+----------+
	// VER socksç‰ˆæœ¬ï¼Œè¿™é‡Œä¸º0x05
	// REP Relay field,å†…å®¹å–å€¼å¦‚ä¸‹ Xâ€™00â€™ succeeded
	// RSV ä¿ç•™å­—æ®µ
	// ATYPE åœ°å€ç±»å‹
	// BND.ADDR æœåŠ¡ç»‘å®šçš„åœ°å€
	// BND.PORT æœåŠ¡ç»‘å®šçš„ç«¯å£DST.PORT
	_, err = conn.Write([]byte{0x05, 0x00, 0x00, 0x01, 0, 0, 0, 0, 0, 0})
	if err != nil {
		return fmt.Errorf("write failed: %w", err)
	}
	return nil
}

```



## END é“¾æ¥

+ [å›åˆ°ç›®å½•](../README.md)
+ [ä¸Šä¸€èŠ‚](23.md)
+ [ä¸‹ä¸€èŠ‚](25.md)
---
+ [å‚ä¸è´¡çŒ®â¤ï¸ğŸ’•ğŸ’•](https://github.com/cubxxw/awesome-cs-cloudnative-blockchain/blob/master/Git/git-contributor.md)