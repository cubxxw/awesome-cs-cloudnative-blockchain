

[toc]

ðŸ˜¶â€ðŸŒ«ï¸goè¯­è¨€å®˜æ–¹ç¼–ç¨‹æŒ‡å—ï¼š[https://golang.org/#](https://golang.org/#)  

>   goè¯­è¨€çš„å®˜æ–¹æ–‡æ¡£å­¦ä¹ ç¬”è®°å¾ˆå…¨ï¼ŒæŽ¨èåŽ»å®˜ç½‘å­¦ä¹ 

ðŸ˜¶â€ðŸŒ«ï¸æˆ‘çš„å­¦ä¹ ç¬”è®°ï¼šgithub: [https://github.com/3293172751/golang-rearn](https://github.com/3293172751/golang-rearn)

---

**åŒºå—é“¾æŠ€æœ¯ï¼ˆä¹Ÿç§°ä¹‹ä¸ºåˆ†å¸ƒå¼è´¦æœ¬æŠ€æœ¯ï¼‰**ï¼Œæ˜¯ä¸€ç§äº’è”ç½‘æ•°æ®åº“æŠ€æœ¯ï¼Œå…¶ç‰¹ç‚¹æ˜¯åŽ»ä¸­å¿ƒåŒ–ï¼Œå…¬å¼€é€æ˜Žï¼Œè®©æ¯ä¸€ä¸ªäººå‡å¯å‚ä¸Žçš„æ•°æ®åº“è®°å½•

>   â¤ï¸ðŸ’•ðŸ’•å…³äºŽåŒºå—é“¾æŠ€æœ¯ï¼Œå¯ä»¥å…³æ³¨æˆ‘ï¼Œå…±åŒå­¦ä¹ æ›´å¤šçš„åŒºå—é“¾æŠ€æœ¯ã€‚åšå®¢[http://nsddd.top](http://nsddd.top)

---

 # chançŽ¯å½¢é˜Ÿåˆ— å…ˆè¿›å…ˆå‡º

# 1 çŽ¯å½¢ç¼“å†²åŒº
## 1.1 çŽ¯å½¢ç¼“å†²åŒºç»“æž„
â€‹       çŽ¯å½¢ç¼“å†²åŒºé€šå¸¸æœ‰ä¸€ä¸ªè¯»æŒ‡é’ˆå’Œä¸€ä¸ªå†™æŒ‡é’ˆã€‚è¯»æŒ‡é’ˆæŒ‡å‘çŽ¯å½¢ç¼“å†²åŒºä¸­å¯è¯»çš„æ•°æ®ï¼Œå†™æŒ‡é’ˆæŒ‡å‘çŽ¯å½¢ç¼“å†²åŒºä¸­å¯å†™çš„ç¼“å†²åŒºã€‚é€šè¿‡ç§»åŠ¨è¯»æŒ‡é’ˆå’Œå†™æŒ‡é’ˆå°±å¯ä»¥å®žçŽ°ç¼“å†²åŒºçš„æ•°æ®è¯»å–å’Œå†™å…¥ã€‚åœ¨é€šå¸¸æƒ…å†µä¸‹ï¼ŒçŽ¯å½¢ç¼“å†²åŒºçš„è¯»ç”¨æˆ·ä»…ä»…ä¼šå½±å“è¯»æŒ‡é’ˆï¼Œè€Œå†™ç”¨æˆ·ä»…ä»…ä¼šå½±å“å†™æŒ‡é’ˆã€‚å¦‚æžœä»…ä»…æœ‰ä¸€ä¸ªè¯»ç”¨æˆ·å’Œä¸€ä¸ªå†™ç”¨æˆ·ï¼Œé‚£ä¹ˆä¸éœ€è¦æ·»åŠ äº’æ–¥ä¿æŠ¤æœºåˆ¶å°±å¯ä»¥ä¿è¯æ•°æ®çš„æ­£ç¡®æ€§ã€‚å¦‚æžœæœ‰å¤šä¸ªè¯»å†™ç”¨æˆ·è®¿é—®çŽ¯å½¢ç¼“å†²åŒºï¼Œé‚£ä¹ˆå¿…é¡»æ·»åŠ äº’æ–¥ä¿æŠ¤æœºåˆ¶æ¥ç¡®ä¿å¤šä¸ªç”¨æˆ·äº’æ–¥è®¿é—®çŽ¯å½¢ç¼“å†²åŒºã€‚

## 1.2 çŽ¯å½¢ç¼“å†²åŒºä¸€ç§è¯»å†™å®žçŽ°æœºåˆ¶
ä¸€èˆ¬çš„ï¼Œåœ†å½¢ç¼“å†²åŒºéœ€è¦4ä¸ªæŒ‡é’ˆ

åœ¨å†…å­˜ä¸­å®žé™…å¼€å§‹ä½ç½®ï¼›

**åœ¨å†…å­˜ä¸­å®žé™…ç»“æŸä½ç½®ï¼Œä¹Ÿå¯ä»¥ç”¨ç¼“å†²åŒºé•¿åº¦ä»£æ›¿ï¼›**

**å­˜å‚¨åœ¨ç¼“å†²åŒºä¸­çš„æœ‰æ•ˆæ•°æ®çš„å¼€å§‹ä½ç½®ï¼ˆè¯»æŒ‡é’ˆï¼‰ï¼›**

**å­˜å‚¨åœ¨ç¼“å†²åŒºä¸­çš„æœ‰æ•ˆæ•°æ®çš„ç»“å°¾ä½ç½®ï¼ˆå†™æŒ‡é’ˆï¼‰ã€‚**

ç¼“å†²åŒºæ˜¯æ»¡ã€æˆ–æ˜¯ç©ºï¼Œéƒ½æœ‰å¯èƒ½å‡ºçŽ°è¯»æŒ‡é’ˆä¸Žå†™æŒ‡é’ˆæŒ‡å‘åŒä¸€ä½ç½®ï¼š

ç¼“å†²åŒºä¸­æ€»æ˜¯æœ‰ä¸€ä¸ªå­˜å‚¨å•å…ƒä¿æŒæœªä½¿ç”¨çŠ¶æ€ã€‚ç¼“å†²åŒºæœ€å¤šå­˜å…¥ï¼ˆsize-1ï¼‰ä¸ªæ•°æ®ã€‚å¦‚æžœè¯»å†™æŒ‡é’ˆæŒ‡å‘åŒä¸€ä½ç½®ï¼Œåˆ™ç¼“å†²åŒºä¸ºç©ºã€‚å¦‚æžœå†™æŒ‡é’ˆä½äºŽè¯»æŒ‡é’ˆçš„ç›¸é‚»åŽä¸€ä¸ªä½ç½®ï¼Œåˆ™ç¼“å†²åŒºä¸ºæ»¡ã€‚

![img](https://s2.loli.net/2022/03/20/6EgmtVuvlj2YMxU.jpg)



## 2 chanå†…éƒ¨æ•°æ®ç»“æž„

### 2.1 chançš„æ•°æ®ç»“æž„

**chanå®žè´¨æ˜¯ä¸ªçŽ¯å½¢ç¼“å†²åŒºï¼Œå¤–åŠ ä¸€ä¸ªæŽ¥å—è€…åç¨‹é˜Ÿåˆ—å’Œä¸€ä¸ªå‘é€è€…åç¨‹é˜Ÿåˆ—**

```
buf      ï¼šçŽ¯å½¢ç¼“å†²åŒº
sendx ï¼šç”¨äºŽè®°å½•bufè¿™ä¸ªå¾ªçŽ¯é“¾è¡¨ä¸­çš„å‘é€çš„index
recvx  ï¼šç”¨äºŽè®°å½•bufè¿™ä¸ªå¾ªçŽ¯é“¾è¡¨ä¸­æŽ¥æ”¶çš„index
recvq  ï¼šæŽ¥å—è€…åç¨‹é˜Ÿåˆ—
sendq ï¼šå‘é€è€…åç¨‹é˜Ÿåˆ—
lock    ï¼šäº’æ–¥é”
```


### 2.2 æœ‰ç¼“å†²åŒºå’Œæ— ç¼“å†²åŒºchançš„åŒºåˆ«
##### 2.2.1 æ— ç¼“å†²chanæ•°æ®åŒæ­¥è¿‡ç¨‹å’Œsudogç»“æž„
åˆ›å»ºä¸€ä¸ªå‘é€è€…åˆ—è¡¨å’ŒæŽ¥æ”¶è€…åˆ—è¡¨éƒ½ä¸ºç©ºçš„ channelã€‚
ç¬¬ä¸€ä¸ªåç¨‹å‘ channel å‘é€å˜é‡çš„å€¼
channel ä»Žæ± ä¸­èŽ·å–ä¸€ä¸ªsudogç»“æž„ä½“å˜é‡ï¼Œç”¨äºŽè¡¨ç¤ºå‘é€è€…ã€‚sudog ç»“æž„ä½“ä¼šä¿æŒå¯¹å‘é€è€…æ‰€åœ¨åç¨‹çš„å¼•ç”¨ï¼Œä»¥åŠå‘é€å˜é‡çš„å¼•ç”¨ã€‚
å‘é€è€…åŠ å…¥sendqé˜Ÿåˆ—ã€‚
å‘é€è€…åç¨‹è¿›å…¥ç­‰å¾…çŠ¶æ€ã€‚
ç¬¬äºŒä¸ªåç¨‹å°†ä»Ž channel ä¸­è¯»å–ä¸€ä¸ªæ¶ˆæ¯
channel å°†sendqåˆ—è¡¨ä¸­ç­‰å¾…çŠ¶æ€çš„å‘é€è€…å‡ºé˜Ÿåˆ—ã€‚
chanel ä½¿ç”¨memmoveå‡½æ•°å°†å‘é€è€…è¦å‘é€çš„å€¼è¿›è¡Œæ‹·è´ï¼ŒåŒ…è£…å…¥sudogç»“æž„ä½“ï¼Œå†ä¼ é€’ç»™ channel æŽ¥æ”¶è€…çš„æŽ¥æ”¶å˜é‡ã€‚
åœ¨ç¬¬äº”æ­¥ä¸­è¢«æŒ‚èµ·çš„ç¬¬ä¸€ä¸ªåç¨‹å°†æ¢å¤è¿è¡Œå¹¶é‡Šæ”¾ç¬¬ä¸‰æ­¥ä¸­èŽ·å–çš„sudogç»“æž„ä½“ã€‚

##### 2.2.1 æœ‰ç¼“å†²chan

æœ‰ç¼“å†²chanå®žè´¨æ˜¯ä½¿ç”¨äº†å®Œæ•´çš„çŽ¯å½¢ç¼“å†²åŒºï¼Œåªè¦ç¼“å†²åŒºæœ‰ç©ºé—²ï¼Œåˆ™å‘é€è€…æ— éœ€è¿›å…¥ç­‰å¾…é˜Ÿåˆ—ï¼Œç›´æŽ¥å°†æ•°æ®æ”¾å…¥çŽ¯å½¢ç¼“å†²åŒºä¸­ï¼Œå¦‚æžœç¼“å†²åŒºæœ‰æ•°æ®ï¼ŒæŽ¥å—è€…æ— éœ€è¿›å…¥ç­‰å¾…é˜Ÿåˆ—ï¼Œç›´æŽ¥ä»ŽçŽ¯å½¢ç¼“å†²åŒºä¸­èŽ·å–æ•°æ®ã€‚

## 3 å…³é”®æºç åˆ†æž

### 3.1 chanæ•°æ®ç»“æž„æºç 

```go
type hchan struct {
	qcount   uint           // total data in the queue
	dataqsiz uint           // size of the circular queue
	buf      unsafe.Pointer // points to an array of dataqsiz elements
	elemsize uint16
	closed   uint32
	elemtype *_type // element type
	sendx    uint   // send index
	recvx    uint   // receive index
	recvq    waitq  // list of recv waiters
	sendq    waitq  // list of send waiters
// lock protects all fields in hchan, as well as several
// fields in sudogs blocked on this channel.
//
// Do not change another G's status while holding this lock
// (in particular, do not ready a G), as this can deadlock
// with stack shrinking.
lock mutex
}
```
### 3.2 sudogæ•°æ®ç»“æž„æºç 

```go
// sudog represents a g in a wait list, such as for sending/receiving
// on a channel.
//
// sudog is necessary because the g â†” synchronization object relation
// is many-to-many. A g can be on many wait lists, so there may be
// many sudogs for one g; and many gs may be waiting on the same
// synchronization object, so there may be many sudogs for one object.
//
// sudogs are allocated from a special pool. Use acquireSudog and
// releaseSudog to allocate and free them.
type sudog struct {
	// The following fields are protected by the hchan.lock of the
	// channel this sudog is blocking on. shrinkstack depends on
	// this for sudogs involved in channel ops.
g 		*g
// isSelect indicates g is participating in a select, so
// g.selectDone must be CAS'd to win the wake-up race.
isSelect bool
next     *sudog
prev     *sudog
elem     unsafe.Pointer // data element (may point to stack)
 
// The following fields are never accessed concurrently.
// For channels, waitlink is only accessed by g.
// For semaphores, all fields (including the ones above)
// are only accessed when holding a semaRoot lock.
 
acquiretime int64
releasetime int64
ticket      uint32
parent      *sudog // semaRoot binary tree
waitlink    *sudog // g.waiting list or semaRoot
waittail    *sudog // semaRoot
c           *hchan // channel
}
```
### 3.3 chançš„æž„é€ è¿‡ç¨‹

```go
func makechan(t *chantype, size int) *hchan {
	elem := t.elem
// compiler checks this but be safe.
if elem.size >= 1<<16 {
	throw("makechan: invalid channel element type")
}
if hchanSize%maxAlign != 0 || elem.align > maxAlign {
	throw("makechan: bad alignment")
}
 
mem, overflow := math.MulUintptr(elem.size, uintptr(size))
if overflow || mem > maxAlloc-hchanSize || size < 0 {
	panic(plainError("makechan: size out of range"))
}
 
// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.
// buf points into the same allocation, elemtype is persistent.
// SudoG's are referenced from their owning thread so they can't be collected.
// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
var c *hchan
switch {
case mem == 0:
	// Queue or element size is zero.
	c = (*hchan)(mallocgc(hchanSize, nil, true))
	// Race detector uses this location for synchronization.
	c.buf = c.raceaddr()
case elem.ptrdata == 0:
	// Elements do not contain pointers.
	// Allocate hchan and buf in one call.
	c = (*hchan)(mallocgc(hchanSize+mem, nil, true))
	c.buf = add(unsafe.Pointer(c), hchanSize)
default:
	// Elements contain pointers.
	c = new(hchan)
	c.buf = mallocgc(mem, elem, true)
}
 
c.elemsize = uint16(elem.size)
c.elemtype = elem
c.dataqsiz = uint(size)
 
if debugChan {
	print("makechan: chan=", c, "; elemsize=", elem.size, "; dataqsiz=", size, "\n")
}
return c
}
```

å¯ä»¥çœ‹åˆ°ï¼Œå¦‚æžœä¸ä¼ å…¥sizeæˆ–size=0ï¼Œåˆ™æ²¡æœ‰ä¸ºçŽ¯å½¢ç¼“å†²åŒºåˆ†é…å†…å­˜ï¼ŒèŒä½chanç»“æž„åˆ†é…å†…å­˜

### 3.4 æ— ç¼“å†²æ”¶å‘

```go
// Sends and receives on unbuffered or empty-buffered channels are the
// only operations where one running goroutine writes to the stack of
// another running goroutine. The GC assumes that stack writes only
// happen when the goroutine is running and are only done by that
// goroutine. Using a write barrier is sufficient to make up for
// violating that assumption, but the write barrier has to work.
// typedmemmove will call bulkBarrierPreWrite, but the target bytes
// are not in the heap, so that will not help. We arrange to call
// memmove and typeBitsBulkBarrier instead.

func sendDirect(t *_type, sg *sudog, src unsafe.Pointer) {
	// src is on our stack, dst is a slot on another stack.
	// Once we read sg.elem out of sg, it will no longer
	// be updated if the destination's stack gets copied (shrunk).
	// So make sure that no preemption points can happen between read & use.
	dst := sg.elem
	typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size)
	// No need for cgo write barrier checks because dst is always
	// Go memory.
	memmove(dst, src, t.size)

}

func recvDirect(t *_type, sg *sudog, dst unsafe.Pointer) {
	// dst is on our stack or the heap, src is on another stack.
	// The channel is locked, so src will not move during this
	// operation.
	src := sg.elem
	typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size)
	memmove(dst, src, t.size)
}
```



------------------------------------------------
